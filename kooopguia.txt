local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local LocalPlayer = Players.LocalPlayer
local RequestCommandSilent = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent

-- ======================================
-- Utility Functions
-- ======================================

-- Function to always give BTools
local function giveBtools()
	pcall(function()
		RequestCommandSilent:InvokeServer(";btools")
	end)
end

-- Function to run refresh command
local function refreshCommand()
	pcall(function()
		RequestCommandSilent:InvokeServer(";refresh")
	end)
end

-- Function to stop sounds/music
local function stopSounds()
	pcall(function()
		RequestCommandSilent:InvokeServer(";unmusic")
	end)
end

-- Function to set player to R6
local function setR6()
	pcall(function()
		RequestCommandSilent:InvokeServer(";r6")
	end)
end

-- Function to play k00p's theme
local function playK00pTheme()
	pcall(function()
		RequestCommandSilent:InvokeServer(";music 1839246711 ;pitch 0.9 ;volume inf") -- Replace with actual k00p's theme ID if different
	end)
end

-- Run immediately when script executes
giveBtools()

-- Run again every time the player respawns
LocalPlayer.CharacterAdded:Connect(function()
	task.wait(1)
	giveBtools()
end)

-- ======================================
-- GUI Setup (Now Immune to ;hideguis)
-- ======================================

local K0OL = Instance.new("ScreenGui")
K0OL.Name = "k00pgui"
K0OL.ResetOnSpawn = false
K0OL.IgnoreGuiInset = false
K0OL.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
K0OL.Parent = CoreGui -- âœ… Immune to ;hideguis

local k00p = Instance.new("Frame")
k00p.Size = UDim2.new(0, 607, 0, 405)
k00p.Position = UDim2.new(0.5, -303, 0.5, -392)
k00p.BackgroundColor3 = Color3.new(0, 0, 0)
k00p.BorderColor3 = Color3.fromRGB(0, 53, 11)
k00p.BorderSizePixel = 5
k00p.Active = true
k00p.Draggable = true
k00p.Parent = K0OL

local scroll = Instance.new("ScrollingFrame")
scroll.Size = UDim2.new(0, 590, 0, 305)
scroll.Position = UDim2.new(0, 10, 0, 70)
scroll.BackgroundColor3 = Color3.fromRGB(8, 8, 8)
scroll.ScrollBarThickness = 8
scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
scroll.ClipsDescendants = true
scroll.Parent = k00p

local title = Instance.new("TextLabel")
title.Text = "k00pgui f3x"
title.TextSize = 24
title.TextColor3 = Color3.new(1, 1, 1)
title.BackgroundTransparency = 1
title.Size = UDim2.new(1, 0, 0, 60)
title.Position = UDim2.new(0.0124216368, 0, -0.00999999978, 0)
title.TextScaled = true
title.Parent = k00p

-- R6 button (Top Left)
local r6Button = Instance.new("TextButton")
r6Button.Text = "R6"
r6Button.TextSize = 14
r6Button.TextColor3 = Color3.new(1, 1, 1)
r6Button.BackgroundColor3 = Color3.new(0, 0, 0)
r6Button.BorderColor3 = Color3.fromRGB(0, 53, 11)
r6Button.BorderSizePixel = 2
r6Button.Size = UDim2.new(0, 80, 0, 30)
r6Button.Position = UDim2.new(0, 10, 0, 15)
r6Button.Parent = k00p

-- Play k00p's Theme (Below R6) - Wider version
local themeButton = Instance.new("TextButton")
themeButton.Text = "Play k00p's Theme"
themeButton.TextSize = 12
themeButton.TextColor3 = Color3.new(1, 1, 1)
themeButton.BackgroundColor3 = Color3.new(0, 0, 0)
themeButton.BorderColor3 = Color3.fromRGB(0, 53, 11)
themeButton.BorderSizePixel = 2
themeButton.Size = UDim2.new(0, 100, 0, 30)  -- Increased width from 80 to 100
themeButton.Position = UDim2.new(0, 10, 0, 50)
themeButton.Parent = k00p

-- Refresh button (Top Right)
local refreshButton = Instance.new("TextButton")
refreshButton.Text = "Refresh"
refreshButton.TextSize = 14
refreshButton.TextColor3 = Color3.new(1, 1, 1)
refreshButton.BackgroundColor3 = Color3.new(0, 0, 0)
refreshButton.BorderColor3 = Color3.fromRGB(0, 53, 11)
refreshButton.BorderSizePixel = 2
refreshButton.Size = UDim2.new(0, 80, 0, 30)
refreshButton.Position = UDim2.new(1, -90, 0, 15)
refreshButton.Parent = k00p

-- Stop Sounds (Below Refresh)
local stopSoundsButton = Instance.new("TextButton")
stopSoundsButton.Text = "Stop Sounds"
stopSoundsButton.TextSize = 14
stopSoundsButton.TextColor3 = Color3.new(1, 1, 1)
stopSoundsButton.BackgroundColor3 = Color3.new(0, 0, 0)
stopSoundsButton.BorderColor3 = Color3.fromRGB(0, 53, 11)
stopSoundsButton.BorderSizePixel = 2
stopSoundsButton.Size = UDim2.new(0, 80, 0, 30)
stopSoundsButton.Position = UDim2.new(1, -90, 0, 50)
stopSoundsButton.Parent = k00p

local title2 = Instance.new("TextLabel")
title2.Text = ""
title2.TextSize = 18
title2.TextColor3 = Color3.new(1, 1, 1)
title2.BackgroundTransparency = 1
title2.Size = UDim2.new(1, 0, 0, 60)
title2.Position = UDim2.new(0, 0, 0.08, 0)
title2.Parent = k00p

local layout = Instance.new("UIGridLayout")
layout.CellSize = UDim2.new(0, 160, 0, 77)
layout.CellPadding = UDim2.new(0, 10, 0, 10)
layout.FillDirection = Enum.FillDirection.Horizontal
layout.FillDirectionMaxCells = 3
layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
layout.VerticalAlignment = Enum.VerticalAlignment.Top
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Parent = scroll

function BT(text, func)
	local button = Instance.new("TextButton")
	button.BackgroundColor3 = Color3.new(0, 0, 0)
	button.BorderColor3 = Color3.fromRGB(0, 53, 11)
	button.BorderSizePixel = 1
	button.TextColor3 = Color3.new(1, 1, 1)
	button.TextSize = 14
	button.TextScaled = true
	button.Text = text
	button.Size = UDim2.new(0, 300, 0, 200)
	button.Parent = scroll
	button.MouseButton1Click:Connect(func)
end

-- ===============================
-- Button Functionality
-- ===============================

refreshButton.MouseButton1Click:Connect(refreshCommand)
stopSoundsButton.MouseButton1Click:Connect(stopSounds)
r6Button.MouseButton1Click:Connect(setR6)
themeButton.MouseButton1Click:Connect(playK00pTheme)
BT("Decal", function()
	
    local player = game.Players.LocalPlayer
			local char = player.Character
			local tool
			for i,v in player:GetDescendants() do
				if v.Name == "SyncAPI" then
					tool = v.Parent
				end
			end
			for i,v in game.ReplicatedStorage:GetDescendants() do
				if v.Name == "SyncAPI" then
					tool = v.Parent
				end
			end
			--craaa
			remote = tool.SyncAPI.ServerEndpoint
			function _(args)
				remote:InvokeServer(unpack(args))
			end
			function SetCollision(part,boolean)
				local args = {
					[1] = "SyncCollision",
					[2] = {
						[1] = {
							["Part"] = part,
							["CanCollide"] = boolean
						}
					}
				}
				_(args)
			end
			function SetAnchor(boolean,part)
				local args = {
					[1] = "SyncAnchor",
					[2] = {
						[1] = {
							["Part"] = part,
							["Anchored"] = boolean
						}
					}
				}
				_(args)
			end
			function CreatePart(cf,parent)
				local args = {
					[1] = "CreatePart",
					[2] = "Normal",
					[3] = cf,
					[4] = parent
				}
				_(args)
			end
			function DestroyPart(part)
				local args = {
					[1] = "Remove",
					[2] = {
						[1] = part
					}
				}
				_(args)
			end
			function MovePart(part,cf)
				local args = {
					[1] = "SyncMove",
					[2] = {
						[1] = {
							["Part"] = part,
							["CFrame"] = cf
						}
					}
				}
				_(args)
			end
			function Resize(part,size,cf)
				local args = {
					[1] = "SyncResize",
					[2] = {
						[1] = {
							["Part"] = part,
							["CFrame"] = cf,
							["Size"] = size
						}
					}
				}
				_(args)
			end
			function AddMesh(part)
				local args = {
					[1] = "CreateMeshes",
					[2] = {
						[1] = {
							["Part"] = part
						}
					}
				}
				_(args)
			end
	
			function SetMesh(part,meshid)
				local args = {
					[1] = "SyncMesh",
					[2] = {
						[1] = {
							["Part"] = part,
							["MeshId"] = "rbxassetid://"..meshid
						}
					}
				}
				_(args)
			end
			function SetTexture(part, texid)
				local args = {
					[1] = "SyncMesh",
					[2] = {
						[1] = {
							["Part"] = part,
							["TextureId"] = "rbxassetid://"..texid
						}
					}
				}
				_(args)
			end
			function SetName(part, stringg)
				local args = {
					[1] = "SetName",
					[2] = {
						[1] = part
					},
					[3] = stringg
				}
	
				_(args)
			end
			function MeshResize(part,size)
				local args = {
					[1] = "SyncMesh",
					[2] = {
						[1] = {
							["Part"] = part,
							["Scale"] = size
						}
					}
				}
				_(args)
			end
			function Weld(part1, part2,lead)
				local args = {
					[1] = "CreateWelds",
					[2] = {
						[1] = part1,
						[2] = part2
					},
					[3] = lead
				}
				_(args)
	
			end
			function SetLocked(part,boolean)
				local args = {
					[1] = "SetLocked",
					[2] = {
						[1] = part
					},
					[3] = boolean
				}
				_(args)
			end
			function SetTrans(part,int)
				local args = {
					[1] = "SyncMaterial",
					[2] = {
						[1] = {
							["Part"] = part,
							["Transparency"] = int
						}
					}
				}
				_(args)
			end
			function CreateSpotlight(part)
				local args = {
					[1] = "CreateLights",
					[2] = {
						[1] = {
							["Part"] = part,
							["LightType"] = "SpotLight"
						}
					}
				}
				_(args)
			end
			function SyncLighting(part,brightness)
				local args = {
					[1] = "SyncLighting",
					[2] = {
						[1] = {
							["Part"] = part,
							["LightType"] = "SpotLight",
							["Brightness"] = brightness
						}
					}
				}
				_(args)
			end
			function Color(part,color)
				local args = {
					[1] = "SyncColor",
					[2] = {
						[1] = {
							["Part"] = part,
							["Color"] = color --[[Color3]],
							["UnionColoring"] = false
						}
					}
				}
				_(args)
			end
			function SpawnDecal(part,side)
				local args = {
					[1] = "CreateTextures",
					[2] = {
						[1] = {
							["Part"] = part,
							["Face"] = side,
							["TextureType"] = "Decal"
						}
					}
				}
	
				_(args)
			end
			function AddDecal(part,asset,side)
				local args = {
					[1] = "SyncTexture",
					[2] = {
						[1] = {
							["Part"] = part,
							["Face"] = side,
							["TextureType"] = "Decal",
							["Texture"] = "rbxassetid://".. asset
						}
					}
				}
				_(args)
			end
	
			function spam(id)
				for i,v in game.workspace:GetDescendants() do
					if v:IsA("BasePart") then
						spawn(function()
							SetLocked(v,false)
							SpawnDecal(v,Enum.NormalId.Front)
							AddDecal(v,id,Enum.NormalId.Front)
	
							SpawnDecal(v,Enum.NormalId.Back)
							AddDecal(v,id,Enum.NormalId.Back)
	
							SpawnDecal(v,Enum.NormalId.Right)
							AddDecal(v,id,Enum.NormalId.Right)
	
							SpawnDecal(v,Enum.NormalId.Left)
							AddDecal(v,id,Enum.NormalId.Left)
	
							SpawnDecal(v,Enum.NormalId.Bottom)
							AddDecal(v,id,Enum.NormalId.Bottom)
	
							SpawnDecal(v,Enum.NormalId.Top)
							AddDecal(v,id,Enum.NormalId.Top)
						end)
					end
				end 
			end
			spam("9422866248")
end)
BT("SkyBox", function()
RequestCommandSilent:InvokeServer(";fogcolor black ;time 6")
local player = game.Players.LocalPlayer

    local char = player.Character

    local tool

    for i,v in player:GetDescendants() do

        if v.Name == "SyncAPI" then

            tool = v.Parent

        end

    end

    for i,v in game.ReplicatedStorage:GetDescendants() do

        if v.Name == "SyncAPI" then

            tool = v.Parent

        end

    end

    --craaa

    remote = tool.SyncAPI.ServerEndpoint

    function _(args)

        remote:InvokeServer(unpack(args))

    end

    function SetCollision(part,boolean)

        local args = {

            [1] = "SyncCollision",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["CanCollide"] = boolean

                }

            }

        }

        _(args)

    end

    function SetAnchor(boolean,part)

        local args = {

            [1] = "SyncAnchor",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Anchored"] = boolean

                }

            }

        }

        _(args)

    end

    function CreatePart(cf,parent)

        local args = {

            [1] = "CreatePart",

            [2] = "Normal",

            [3] = cf,

            [4] = parent

        }

        _(args)

    end

    function DestroyPart(part)

        local args = {

            [1] = "Remove",

            [2] = {

                [1] = part

            }

        }

        _(args)

    end

    function MovePart(part,cf)

        local args = {

            [1] = "SyncMove",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["CFrame"] = cf

                }

            }

        }

        _(args)

    end

    function Resize(part,size,cf)

        local args = {

            [1] = "SyncResize",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["CFrame"] = cf,

                    ["Size"] = size

                }

            }

        }

       _(args)

    end

    function AddMesh(part)

        local args = {

            [1] = "CreateMeshes",

            [2] = {

                [1] = {

                    ["Part"] = part

                }

            }

        }

        _(args)

    end

    function SetMesh(part,meshid)

        local args = {

            [1] = "SyncMesh",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["MeshId"] = "rbxassetid://"..meshid

                }

            }

        }

        _(args)

    end

    function SetTexture(part, texid)

        local args = {

            [1] = "SyncMesh",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["TextureId"] = "rbxassetid://"..texid

                }

            }

        }

        _(args)

    end

    function SetName(part, stringg)

        local args = {

            [1] = "SetName",

            [2] = {

                [1] = part

            },

            [3] = stringg

        }

        _(args)

    end

    function MeshResize(part,size)

        local args = {

            [1] = "SyncMesh",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Scale"] = size

                }

            }

        }

        _(args)

    end

    function Weld(part1, part2,lead)

        local args = {

            [1] = "CreateWelds",

            [2] = {

                [1] = part1,

                [2] = part2

            },

            [3] = lead

        }

        _(args)

    end

    function SetLocked(part,boolean)

        local args = {

            [1] = "SetLocked",

            [2] = {

                [1] = part

            },

            [3] = boolean

        }

        _(args)

    end

    function SetTrans(part,int)

        local args = {

            [1] = "SyncMaterial",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Transparency"] = int

                }

            }

        }

        _(args)

    end

    function CreateSpotlight(part)

        local args = {

           [1] = "CreateLights",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["LightType"] = "SpotLight"

                }

            }

        }

        _(args)

    end

    function SyncLighting(part,brightness)

        local args = {

            [1] = "SyncLighting",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["LightType"] = "SpotLight",

                    ["Brightness"] = brightness

                }

            }

        }

        _(args)

    end

    function Color(part,color)

        local args = {

            [1] = "SyncColor",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Color"] = color --[[Color3]],

                    ["UnionColoring"] = false

                }

            }

        }

        _(args)

    end

    function SpawnDecal(part,side)

        local args = {

            [1] = "CreateTextures",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Face"] = side,

                    ["TextureType"] = "Decal"

                }

            }

        }

        _(args)

    end

    function AddDecal(part,asset,side)

        local args = {

            [1] = "SyncTexture",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Face"] = side,

                    ["TextureType"] = "Decal",

                    ["Texture"] = "rbxassetid://".. asset

                }

            }

        }

        _(args)

    end

    function Sky(id)

        e = char.HumanoidRootPart.CFrame.x

        f = char.HumanoidRootPart.CFrame.y

        g = char.HumanoidRootPart.CFrame.z

        CreatePart(CFrame.new(math.floor(e),math.floor(f),math.floor(g)) + Vector3.new(0,6,0),workspace)

        for i,v in game.Workspace:GetDescendants() do

            if v:IsA("BasePart") and v.CFrame.x == math.floor(e) and v.CFrame.z == math.floor(g) then

                --spawn(function()

                SetName(v,"Sky")

                AddMesh(v)

                --end)

                --spawn(function()

                SetMesh(v,"111891702759441")

                SetTexture(v,id)

                --end)

                MeshResize(v,Vector3.new(99999,99999,99999))

                SetLocked(v,true)

            end

        end

    end

    Sky("9422866248")
end)

BT("SkyBox 2", function()
RequestCommandSilent:InvokeServer(";fogcolor black ;time 6")
local player = game.Players.LocalPlayer

    local char = player.Character

    local tool

    for i,v in player:GetDescendants() do

        if v.Name == "SyncAPI" then

            tool = v.Parent

        end

    end

    for i,v in game.ReplicatedStorage:GetDescendants() do

        if v.Name == "SyncAPI" then

            tool = v.Parent

        end

    end

    --craaa

    remote = tool.SyncAPI.ServerEndpoint

    function _(args)

        remote:InvokeServer(unpack(args))

    end

    function SetCollision(part,boolean)

        local args = {

            [1] = "SyncCollision",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["CanCollide"] = boolean

                }

            }

        }

        _(args)

    end

    function SetAnchor(boolean,part)

        local args = {

            [1] = "SyncAnchor",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Anchored"] = boolean

                }

            }

        }

        _(args)

    end

    function CreatePart(cf,parent)

        local args = {

            [1] = "CreatePart",

            [2] = "Normal",

            [3] = cf,

            [4] = parent

        }

        _(args)

    end

    function DestroyPart(part)

        local args = {

            [1] = "Remove",

            [2] = {

                [1] = part

            }

        }

        _(args)

    end

    function MovePart(part,cf)

        local args = {

            [1] = "SyncMove",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["CFrame"] = cf

                }

            }

        }

        _(args)

    end

    function Resize(part,size,cf)

        local args = {

            [1] = "SyncResize",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["CFrame"] = cf,

                    ["Size"] = size

                }

            }

        }

       _(args)

    end

    function AddMesh(part)

        local args = {

            [1] = "CreateMeshes",

            [2] = {

                [1] = {

                    ["Part"] = part

                }

            }

        }

        _(args)

    end

    function SetMesh(part,meshid)

        local args = {

            [1] = "SyncMesh",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["MeshId"] = "rbxassetid://"..meshid

                }

            }

        }

        _(args)

    end

    function SetTexture(part, texid)

        local args = {

            [1] = "SyncMesh",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["TextureId"] = "rbxassetid://"..texid

                }

            }

        }

        _(args)

    end

    function SetName(part, stringg)

        local args = {

            [1] = "SetName",

            [2] = {

                [1] = part

            },

            [3] = stringg

        }

        _(args)

    end

    function MeshResize(part,size)

        local args = {

            [1] = "SyncMesh",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Scale"] = size

                }

            }

        }

        _(args)

    end

    function Weld(part1, part2,lead)

        local args = {

            [1] = "CreateWelds",

            [2] = {

                [1] = part1,

                [2] = part2

            },

            [3] = lead

        }

        _(args)

    end

    function SetLocked(part,boolean)

        local args = {

            [1] = "SetLocked",

            [2] = {

                [1] = part

            },

            [3] = boolean

        }

        _(args)

    end

    function SetTrans(part,int)

        local args = {

            [1] = "SyncMaterial",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Transparency"] = int

                }

            }

        }

        _(args)

    end

    function CreateSpotlight(part)

        local args = {

           [1] = "CreateLights",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["LightType"] = "SpotLight"

                }

            }

        }

        _(args)

    end

    function SyncLighting(part,brightness)

        local args = {

            [1] = "SyncLighting",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["LightType"] = "SpotLight",

                    ["Brightness"] = brightness

                }

            }

        }

        _(args)

    end

    function Color(part,color)

        local args = {

            [1] = "SyncColor",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Color"] = color --[[Color3]],

                    ["UnionColoring"] = false

                }

            }

        }

        _(args)

    end

    function SpawnDecal(part,side)

        local args = {

            [1] = "CreateTextures",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Face"] = side,

                    ["TextureType"] = "Decal"

                }

            }

        }

        _(args)

    end

    function AddDecal(part,asset,side)

        local args = {

            [1] = "SyncTexture",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Face"] = side,

                    ["TextureType"] = "Decal",

                    ["Texture"] = "rbxassetid://".. asset

                }

            }

        }

        _(args)

    end

    function Sky(id)

        e = char.HumanoidRootPart.CFrame.x

        f = char.HumanoidRootPart.CFrame.y

        g = char.HumanoidRootPart.CFrame.z

        CreatePart(CFrame.new(math.floor(e),math.floor(f),math.floor(g)) + Vector3.new(0,6,0),workspace)

        for i,v in game.Workspace:GetDescendants() do

            if v:IsA("BasePart") and v.CFrame.x == math.floor(e) and v.CFrame.z == math.floor(g) then

                --spawn(function()

                SetName(v,"Sky")

                AddMesh(v)

                --end)

                --spawn(function()

                SetMesh(v,"111891702759441")

                SetTexture(v,id)

                --end)

                MeshResize(v,Vector3.new(90000,90000,90000))

                SetLocked(v,true)

            end

        end

    end

    Sky("11426185601")
end)

BT("Hint", function()
	RequestCommandSilent:InvokeServer(";sh TEAM K00PKIDD HAS HACKED THIS GAME.")
end)

BT("Particles", function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Try to find SyncAPI in player first
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end
-- If not found, check ReplicatedStorage
if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end
if not tool then
    error("SyncAPI tool not found")
end

local remote = tool.SyncAPI.ServerEndpoint

--// Simple remote call wrapper
local function _(args)
    remote:InvokeServer(unpack(args))
end

--// Helper functions
local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end
local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end
local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end
local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end
local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end
local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end
local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end
local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end
local function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end
local function SpawnDecal(part, face)
    _({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end
local function AddDecal(part, asset, face)
    _({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset}}})
end
local function SetName(part, name)
    _({"SetName", {part}, name})
end
local function SetTrans(part, val)
    _({"SyncMaterial", {{Part = part, Transparency = val}}})
end
local function delete(part)
    _({"Remove", {part}})
end

--// === Improved Particle Effect System ===
local activeParticles = {}
local particleCooldowns = {}

local function createParticleForPlayer(targetPlayer, textureId)
    -- Wait for character to load
    local character = targetPlayer.Character
    if not character then
        targetPlayer.CharacterAdded:Wait()
        character = targetPlayer.Character
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local playerKey = targetPlayer.UserId
    
    -- Initialize cooldown for this player/texture combination
    local cooldownKey = playerKey .. "_" .. textureId
    particleCooldowns[cooldownKey] = particleCooldowns[cooldownKey] or 0
    
    while true do
        local currentTime = tick()
        
        -- Check cooldown (2 seconds between particles)
        if currentTime - particleCooldowns[cooldownKey] >= 2 then
            particleCooldowns[cooldownKey] = currentTime
            
            -- Check if player and character are still valid
            if not targetPlayer or not targetPlayer.Parent or not character or not character.Parent or humanoid.Health <= 0 then
                break
            end
            
            local head = character:FindFirstChild("Head")
            if not head then
                task.wait(1)
                continue
            end

            -- Spawn particle above head
            local spawnCFrame = head.CFrame + Vector3.new(0, 3, 0)
            
            task.spawn(function()  
                CreatePart(spawnCFrame, workspace)  
                task.wait(0.1)  
                
                local newPart = nil
                for _, v in workspace:GetChildren() do  
                    if v:IsA("Part") and (v.Position - spawnCFrame.Position).Magnitude < 1 then  
                        newPart = v
                        break
                    end  
                end
                
                if newPart then
                    SetName(newPart, "particle_" .. targetPlayer.Name .. "_" .. textureId)  
                    Resize(newPart, Vector3.new(6, 6, 0.001), newPart.CFrame)  
                    SetCollision(newPart, false)  
                    SetTrans(newPart, 1)  
                    SetAnchor(newPart, true)  
                    newPart.Orientation = Vector3.new(0, 0, 0)  

                    SpawnDecal(newPart, Enum.NormalId.Front)  
                    AddDecal(newPart, textureId, Enum.NormalId.Front)  
                    SpawnDecal(newPart, Enum.NormalId.Back)  
                    AddDecal(newPart, textureId, Enum.NormalId.Back)  

                    -- Track this particle
                    local particleId = #activeParticles + 1
                    activeParticles[particleId] = newPart

                    -- Animate particle rising up
                    for i = 1, 40 do  -- Reduced frames for faster cleanup
                        if newPart and newPart.Parent and head and head.Parent then  
                            local currentHeadPos = head.Position
                            local newPosition = Vector3.new(
                                currentHeadPos.X,
                                spawnCFrame.Position.Y + (i * 2),  -- Move up 2 studs per frame
                                currentHeadPos.Z
                            )
                            local newCFrame = CFrame.new(newPosition)
                            Resize(newPart, newPart.Size, newCFrame)  
                            task.wait(0.05)  -- Slightly faster animation
                        else
                            break
                        end
                    end  
                    
                    -- Cleanup
                    if newPart and newPart.Parent then
                        delete(newPart)  
                    end
                    activeParticles[particleId] = nil
                end  
            end)  
        end
        
        task.wait(0.5) -- Check every 0.5 seconds instead of 0.1
    end
end

--// === Manage Particles for All Players ===
local function startParticleSystem()
    local textureIds = {"90174292761643"}
    local activeConnections = {}
    
    -- Function to start particles for a specific player
    local function startForPlayer(player)
        for _, texId in ipairs(textureIds) do
            coroutine.wrap(function()
                createParticleForPlayer(player, texId)
            end)()
        end
    end
    
    -- Function to stop particles for a specific player
    local function stopForPlayer(player)
        -- Clean up any particles for this player
        for particleId, part in pairs(activeParticles) do
            if part.Name:find(player.Name) and part.Parent then
                delete(part)
                activeParticles[particleId] = nil
            end
        end
    end
    
    -- Start particles for all current players
    for _, existingPlayer in ipairs(Players:GetPlayers()) do
        startForPlayer(existingPlayer)
    end
    
    -- Listen for new players
    Players.PlayerAdded:Connect(function(newPlayer)
        startForPlayer(newPlayer)
    end)
    
    -- Listen for players leaving
    Players.PlayerRemoving:Connect(function(leavingPlayer)
        stopForPlayer(leavingPlayer)
    end)
end

--// === Cleanup System ===
local function setupCleanup()
    -- Periodic cleanup of any orphaned particles
    while true do
        task.wait(10) -- Clean up every 10 seconds
        for particleId, part in pairs(activeParticles) do
            if not part or not part.Parent then
                activeParticles[particleId] = nil
            end
        end
    end
end

--// === Run Particle System ===
startParticleSystem()
coroutine.wrap(setupCleanup)()
end)
BT("Particles 2", function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Try to find SyncAPI in player first
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end
-- If not found, check ReplicatedStorage
if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end
if not tool then
    error("SyncAPI tool not found")
end

local remote = tool.SyncAPI.ServerEndpoint

--// Simple remote call wrapper
local function _(args)
    remote:InvokeServer(unpack(args))
end

--// Helper functions
local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end
local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end
local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end
local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end
local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end
local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end
local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end
local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end
local function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end
local function SpawnDecal(part, face)
    _({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end
local function AddDecal(part, asset, face)
    _({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset}}})
end
local function SetName(part, name)
    _({"SetName", {part}, name})
end
local function SetTrans(part, val)
    _({"SyncMaterial", {{Part = part, Transparency = val}}})
end
local function delete(part)
    _({"Remove", {part}})
end

--// === Improved Particle Effect System ===
local activeParticles = {}
local particleCooldowns = {}

local function createParticleForPlayer(targetPlayer, textureId)
    -- Wait for character to load
    local character = targetPlayer.Character
    if not character then
        targetPlayer.CharacterAdded:Wait()
        character = targetPlayer.Character
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local playerKey = targetPlayer.UserId
    
    -- Initialize cooldown for this player/texture combination
    local cooldownKey = playerKey .. "_" .. textureId
    particleCooldowns[cooldownKey] = particleCooldowns[cooldownKey] or 0
    
    while true do
        local currentTime = tick()
        
        -- Check cooldown (2 seconds between particles)
        if currentTime - particleCooldowns[cooldownKey] >= 2 then
            particleCooldowns[cooldownKey] = currentTime
            
            -- Check if player and character are still valid
            if not targetPlayer or not targetPlayer.Parent or not character or not character.Parent or humanoid.Health <= 0 then
                break
            end
            
            local head = character:FindFirstChild("Head")
            if not head then
                task.wait(1)
                continue
            end

            -- Spawn particle above head
            local spawnCFrame = head.CFrame + Vector3.new(0, 3, 0)
            
            task.spawn(function()  
                CreatePart(spawnCFrame, workspace)  
                task.wait(0.1)  
                
                local newPart = nil
                for _, v in workspace:GetChildren() do  
                    if v:IsA("Part") and (v.Position - spawnCFrame.Position).Magnitude < 1 then  
                        newPart = v
                        break
                    end  
                end
                
                if newPart then
                    SetName(newPart, "particle_" .. targetPlayer.Name .. "_" .. textureId)  
                    Resize(newPart, Vector3.new(6, 6, 0.001), newPart.CFrame)  
                    SetCollision(newPart, false)  
                    SetTrans(newPart, 1)  
                    SetAnchor(newPart, true)  
                    newPart.Orientation = Vector3.new(0, 0, 0)  

                    SpawnDecal(newPart, Enum.NormalId.Front)  
                    AddDecal(newPart, textureId, Enum.NormalId.Front)  
                    SpawnDecal(newPart, Enum.NormalId.Back)  
                    AddDecal(newPart, textureId, Enum.NormalId.Back)  

                    -- Track this particle
                    local particleId = #activeParticles + 1
                    activeParticles[particleId] = newPart

                    -- Animate particle rising up
                    for i = 1, 40 do  -- Reduced frames for faster cleanup
                        if newPart and newPart.Parent and head and head.Parent then  
                            local currentHeadPos = head.Position
                            local newPosition = Vector3.new(
                                currentHeadPos.X,
                                spawnCFrame.Position.Y + (i * 2),  -- Move up 2 studs per frame
                                currentHeadPos.Z
                            )
                            local newCFrame = CFrame.new(newPosition)
                            Resize(newPart, newPart.Size, newCFrame)  
                            task.wait(0.05)  -- Slightly faster animation
                        else
                            break
                        end
                    end  
                    
                    -- Cleanup
                    if newPart and newPart.Parent then
                        delete(newPart)  
                    end
                    activeParticles[particleId] = nil
                end  
            end)  
        end
        
        task.wait(0.5) -- Check every 0.5 seconds instead of 0.1
    end
end

--// === Manage Particles for All Players ===
local function startParticleSystem()
    local textureIds = {"11426291165"}
    local activeConnections = {}
    
    -- Function to start particles for a specific player
    local function startForPlayer(player)
        for _, texId in ipairs(textureIds) do
            coroutine.wrap(function()
                createParticleForPlayer(player, texId)
            end)()
        end
    end
    
    -- Function to stop particles for a specific player
    local function stopForPlayer(player)
        -- Clean up any particles for this player
        for particleId, part in pairs(activeParticles) do
            if part.Name:find(player.Name) and part.Parent then
                delete(part)
                activeParticles[particleId] = nil
            end
        end
    end
    
    -- Start particles for all current players
    for _, existingPlayer in ipairs(Players:GetPlayers()) do
        startForPlayer(existingPlayer)
    end
    
    -- Listen for new players
    Players.PlayerAdded:Connect(function(newPlayer)
        startForPlayer(newPlayer)
    end)
    
    -- Listen for players leaving
    Players.PlayerRemoving:Connect(function(leavingPlayer)
        stopForPlayer(leavingPlayer)
    end)
end

--// === Cleanup System ===
local function setupCleanup()
    -- Periodic cleanup of any orphaned particles
    while true do
        task.wait(10) -- Clean up every 10 seconds
        for particleId, part in pairs(activeParticles) do
            if not part or not part.Parent then
                activeParticles[particleId] = nil
            end
        end
    end
end

--// === Run Particle System ===
startParticleSystem()
coroutine.wrap(setupCleanup)()
end)

BT("666", function()
	
local player = game.Players.LocalPlayer
    local char = player.Character
    local tool
    for i,v in player:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
        end
    end
    for i,v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
        end
    end
    --craaa
    remote = tool.SyncAPI.ServerEndpoint
    function _(args)
        remote:InvokeServer(unpack(args))
    end
    function SetCollision(part,boolean)
        local args = {
            [1] = "SyncCollision",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["CanCollide"] = boolean
                }
            }
        }
        _(args)
    end
    function SetAnchor(boolean,part)
        local args = {
            [1] = "SyncAnchor",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Anchored"] = boolean
                }
            }
        }
        _(args)
    end
    function CreatePart(cf,parent)
        local args = {
            [1] = "CreatePart",
            [2] = "Normal",
            [3] = cf,
            [4] = parent
        }
        _(args)
    end
    function DestroyPart(part)
        local args = {
            [1] = "Remove",
            [2] = {
                [1] = part
            }
        }
        _(args)
    end
    function MovePart(part,cf)
        local args = {
            [1] = "SyncMove",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["CFrame"] = cf
                }
            }
        }
        _(args)
    end
    function Resize(part,size,cf)
        local args = {
            [1] = "SyncResize",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["CFrame"] = cf,
                    ["Size"] = size
                }
            }
        }
        _(args)
    end
    function AddMesh(part)
        local args = {
            [1] = "CreateMeshes",
            [2] = {
                [1] = {
                    ["Part"] = part
                }
            }
        }
        _(args)
    end
 
    function SetMesh(part,meshid)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["MeshId"] = "rbxassetid://"..meshid
                }
            }
        }
        _(args)
    end
    function SetTexture(part, texid)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["TextureId"] = "rbxassetid://"..texid
                }
            }
        }
        _(args)
    end
    function SetName(part, stringg)
        local args = {
            [1] = "SetName",
            [2] = {
                [1] = part
            },
            [3] = stringg
        }
 
        _(args)
    end
    function MeshResize(part,size)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Scale"] = size
                }
            }
        }
        _(args)
    end
    function Weld(part1, part2,lead)
        local args = {
            [1] = "CreateWelds",
            [2] = {
                [1] = part1,
                [2] = part2
            },
            [3] = lead
        }
        _(args)
 
    end
    function SetLocked(part,boolean)
        local args = {
            [1] = "SetLocked",
            [2] = {
                [1] = part
            },
            [3] = boolean
        }
        _(args)
    end
    function SetTrans(part,int)
        local args = {
            [1] = "SyncMaterial",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Transparency"] = int
                }
            }
        }
        _(args)
    end
    function CreateSpotlight(part)
        local args = {
            [1] = "CreateLights",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["LightType"] = "SpotLight"
                }
            }
        }
        _(args)
    end
    function SyncLighting(part,brightness)
        local args = {
            [1] = "SyncLighting",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["LightType"] = "SpotLight",
                    ["Brightness"] = brightness
                }
            }
        }
        _(args)
    end
    function Color(part,color)
        local args = {
            [1] = "SyncColor",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Color"] = color --[[Color3]],
                    ["UnionColoring"] = false
                }
            }
        }
        _(args)
    end
    function SpawnDecal(part,side)
        local args = {
            [1] = "CreateTextures",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Face"] = side,
                    ["TextureType"] = "Decal"
                }
            }
        }
 
        _(args)
    end
    function AddDecal(part,asset,side)
        local args = {
            [1] = "SyncTexture",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Face"] = side,
                    ["TextureType"] = "Decal",
                    ["Texture"] = "rbxassetid://".. asset
                }
            }
        }
        _(args)
    end
 
    function spam(id)
        for i,v in game.workspace:GetDescendants() do
            if v:IsA("BasePart") then
                spawn(function()
task.wait(0.1)
                    SetLocked(v,false)
                     
                    SpawnDecal(v,Enum.NormalId.Front)
                    AddDecal(v,id,Enum.NormalId.Front)
 
                    SpawnDecal(v,Enum.NormalId.Back)
                    AddDecal(v,id,Enum.NormalId.Back)
 
                    SpawnDecal(v,Enum.NormalId.Right)
                    AddDecal(v,id,Enum.NormalId.Right)
 
                    SpawnDecal(v,Enum.NormalId.Left)
                    AddDecal(v,id,Enum.NormalId.Left)
 
                    SpawnDecal(v,Enum.NormalId.Bottom)
                    AddDecal(v,id,Enum.NormalId.Bottom)
 
                    SpawnDecal(v,Enum.NormalId.Top)
                    AddDecal(v,id,Enum.NormalId.Top)
                end)
            end
        end 
    end
    spam("90095903128986")



    		local function applyDecorationToPart(part)
			local argsCreate = {
				[1] = "CreateDecorations",
				[2] = {
					[1] = {
						["Part"] = part,
						["DecorationType"] = "Fire"
					}
				}
			}

			local argsSync = {
				[1] = "SyncDecorate",
				[2] = {
					[1] = {
						["Part"] = part,
						["DecorationType"] = "Fire",
						["Size"] = 15
					}
				}
			}

			local buildingTools = nil
			local player = game:GetService("Players").LocalPlayer

			-- Search for the tool in Character and Backpack
			for _, item in pairs(player.Character:GetChildren()) do
				if item:IsA("Tool") and item:FindFirstChild("SyncAPI") then
					buildingTools = item
					break
				end
			end

			if not buildingTools then
				for _, item in pairs(player.Backpack:GetChildren()) do
					if item:IsA("Tool") and item:FindFirstChild("SyncAPI") then
						buildingTools = item
						break
					end
				end
			end

			if buildingTools then
				buildingTools.SyncAPI.ServerEndpoint:InvokeServer(unpack(argsCreate))
				buildingTools.SyncAPI.ServerEndpoint:InvokeServer(unpack(argsSync))
			elseif not warned then
				warn("Building tool not found")
				warned = true
			end
		end

		local function applyDecorationToAllParts(workspaceObject)
			for _, obj in pairs(workspaceObject:GetDescendants()) do
				if obj:IsA("Part") or obj:IsA("MeshPart") then
					applyDecorationToPart(obj)
				end
			end
		end

		applyDecorationToAllParts(workspace)


        local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local tool


for _, v in ipairs(LocalPlayer:GetDescendants()) do
	if v.Name == "SyncAPI" then
		tool = v.Parent
		break
	end
end

if not tool then
	for _, v in ipairs(ReplicatedStorage:GetDescendants()) do
		if v.Name == "SyncAPI" then
			tool = v.Parent
			break
		end
	end
end

if not tool then
	warn("dumbass")
	return
end

local remote = tool:WaitForChild("SyncAPI"):WaitForChild("ServerEndpoint")


local function invoke(args)
	remote:InvokeServer(unpack(args))
end


local function applyRedLight(part)
	if not part or not part:IsA("BasePart") then return end


	local createArgs = {
		"CreateLights",
		{
			{
				Part = part,
				LightType = "PointLight"
			}
		}
	}


	local syncArgs = {
		"SyncLighting",
		{
			{
				Part = part,
				LightType = "PointLight",
				Color = Color3.fromRGB(255, 0, 0),
				Range = 60,
				Brightness = 20
			}
		}
	}

	invoke(createArgs)
	invoke(syncArgs)
end

local function applyLightsToAllParts(root)
	for _, obj in ipairs(root:GetDescendants()) do
		if obj:IsA("Part") or obj:IsA("MeshPart") then
			applyRedLight(obj)
		end
	end
end

applyLightsToAllParts(workspace)

RequestCommandSilent:InvokeServer(";titler all 666 666 666 666")
end)

BT("UnAnchor", function()
	local player = game.Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()

local tool

for _, v in player:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

for _, v in game.ReplicatedStorage:GetDescendants() do

	if v.Name == "SyncAPI" then

		tool = v.Parent

	end

end

if not tool or not tool:FindFirstChild("SyncAPI") then

	warn("SyncAPI tool not found!")

	return

end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)

	remote:InvokeServer(unpack(args))

end

function SetCollision(part, boolean)

	local args = {

		"SyncCollision",

		{

			{

				Part = part,

				CanCollide = boolean

			}

		}

	}

	_(args)

end

function SetAnchor(boolean, part)

	local args = {

		"SyncAnchor",

		{

			{

				Part = part,

				Anchored = boolean

			}

		}

	}

	_(args)

end

function CreatePart(cf, parent)

	local args = {

		"CreatePart",

		"Normal",

		cf,

		parent

	}

	_(args)

end

function DestroyPart(part)

	local args = {

		"Remove",

		{

			part

		}

	}

	_(args)

end

function MovePart(part, cf)

	local args = {

		"SyncMove",

		{

			{

				Part = part,

				CFrame = cf

			}

		}

	}

	_(args)

end

function Resize(part, size, cf)

	local args = {

		"SyncResize",

		{

			{

				Part = part,

				CFrame = cf,

				Size = size

			}

		}

	}

	_(args)

end

function AddMesh(part)

	local args = {

		"CreateMeshes",

		{

			{

				Part = part

			}

		}

	}

	_(args)

end

function SetMesh(part, meshid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				MeshId = "rbxassetid://" .. meshid

			}

		}

	}

	_(args)

end

function SetTexture(part, texid)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				TextureId = "rbxassetid://" .. texid

			}

		}

	}

	_(args)

end

function SetName(part, name)

	local args = {

		"SetName",

		{

			part

		},

		name

	}

	_(args)

end

function MeshResize(part, size)

	local args = {

		"SyncMesh",

		{

			{

				Part = part,

				Scale = size

			}

		}

	}

	_(args)

end

function Weld(part1, part2, lead)

	local args = {

		"CreateWelds",

		{

			part1,

			part2

		},

		lead

	}

	_(args)

end

function SetLocked(part, boolean)

	local args = {

		"SetLocked",

		{

			part

		},

		boolean

	}

	_(args)

end

function SetTrans(part, int)

	local args = {

		"SyncMaterial",

		{

			{

				Part = part,

				Transparency = int

			}

		}

	}

	_(args)

end

function CreateSpotlight(part)

	local args = {

		"CreateLights",

		{

			{

				Part = part,

				LightType = "SpotLight"

			}

		}

	}

	_(args)

end

function SyncLighting(part, brightness)

	local args = {

		"SyncLighting",

		{

			{

				Part = part,

				LightType = "SpotLight",

				Brightness = brightness

			}

		}

	}

	_(args)

end

function Unanchor()

	for _, v in workspace:GetDescendants() do

		if v:IsA("BasePart") then

			task.spawn(function()

				SetLocked(v, false)

				SetAnchor(false, v)

			end)

		end

	end

end

Unanchor()
end)

BT("Shutdown", function()
	local plr = game:GetService("Players").LocalPlayer
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local RequestCommandSilent = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
	RequestCommandSilent:InvokeServer(";kick all Teh Game Iz Duked Up!1!")
	wait(1)
	plr:Kick("Teh Game Iz Duked Up!1!")
end)

BT("disco", function()
	RequestCommandSilent:InvokeServer(";disco")
end)

BT("Gravity Hammer", function()
	RequestCommandSilent:InvokeServer(";gear me 48088344")
end)


BT("Message", function()
	RequestCommandSilent:InvokeServer(";sm EL K0PARAZ HAXXORED THIS GAME1!1!1")
end)

BT("Toadroast", function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 153752123")
SilentRequest:InvokeServer(";volume inf")
SilentRequest:InvokeServer(";time 0")
Wait(2)
SilentRequest:InvokeServer(";fogcolor black")

local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function SetCollision(part, boolean)
    local args = {
        [1] = "SyncCollision",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CanCollide"] = boolean
            }
        }
    }
    _(args)
end

function SetAnchor(boolean, part)
    local args = {
        [1] = "SyncAnchor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Anchored"] = boolean
            }
        }
    }
    _(args)
end

function CreatePart(cf, parent)
    local args = {
        [1] = "CreatePart",
        [2] = "Normal",
        [3] = cf,
        [4] = parent
    }
    _(args)
end

function Resize(part, size, cf)
    local args = {
        [1] = "SyncResize",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CFrame"] = cf,
                ["Size"] = size
            }
        }
    }
    _(args)
end

function AddMesh(part)
    local args = {
        [1] = "CreateMeshes",
        [2] = {
            [1] = {
                ["Part"] = part
            }
        }
    }
    _(args)
end

function SetMesh(part, meshid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["MeshId"] = "rbxassetid://" .. meshid
            }
        }
    }
    _(args)
end

function SetTexture(part, texid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["TextureId"] = "rbxassetid://" .. texid
            }
        }
    }
    _(args)
end

function MeshResize(part, size)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Scale"] = size
            }
        }
    }
    _(args)
end

function SetName(part, stringg)
    local args = {
        [1] = "SetName",
        [2] = {
            [1] = workspace.Part
        },
        [3] = stringg
    }
    _(args)
end

function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = hrp.CFrame
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)
    for _, v in workspace:GetDescendants() do
        if v:IsA("BasePart") and v.CFrame.Position == cf.Position + Vector3.new(0, 6, 0) then
            SetAnchor(true, v)
            AddMesh(v)
            SetMesh(v, "111891702759441")
            SetTexture(v, id)
            MeshResize(v, Vector3.new(90000, 90000, 90000))
        end
    end
end

local function createRainToads()
    while true do
        wait(0.3)
        if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local hrpcf = player.Character.HumanoidRootPart.CFrame
            local x = hrpcf.x
            local z = hrpcf.z
            local randint = math.random(-600, 600)
            local randint2 = math.random(-600, 600)
            local xloc = randint + x
            local zloc = randint2 + z
            local cf = player.Character.HumanoidRootPart.CFrame.y + 800  

            spawn(function()
                local newToad = CreatePart(CFrame.new(math.floor(xloc), math.random(cf, cf + 400), math.floor(zloc)), workspace)
                for i, v in game.Workspace:GetDescendants() do
                    if v.Name == "Part" and v.Parent == workspace and v.CFrame.x == math.floor(xloc) and v.CFrame.z == math.floor(zloc) then
                        SetName(v, "MiniToad")
                        SetAnchor(false, v)
                        AddMesh(v)
                        
                        SetMesh(v, "7234998844")
                        SetTexture(v, "1009824086")
                        SetCollision(v, false)
                        v.Orientation = Vector3.new(0, 0, 0)

                        local sound = Instance.new("Sound", v)
                        sound.SoundId = "rbxassetid://153752123"
                        sound.Volume = 10
                        sound.PlayOnRemove = true
                        sound:Destroy()
                    end
                end
            end)
        else
            wait(1)
        end
    end
end

coroutine.wrap(createRainToads)()

Sky("201208408")
local player = game.Players.LocalPlayer
local char = player.Character
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args)
    remote:InvokeServer(unpack(args))
end

function DestroyPart(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

function Punish(player)
    local char = player.Character
    DestroyPart(char)
end

coroutine.wrap(function()
    while true do
        for i, v in game.Players:GetPlayers() do
            pcall(function()
                Punish(v)
            end)
        end
        task.wait(0.0)
    end
end)()

local msg = coroutine.create(function()
    while task.wait(0.4) do
        local msgInstance = Instance.new("Message", workspace)
        msgInstance.Text = "Get Toadroasted by k00pkidd bitch"
        task.wait(0.4)
        msgInstance:Destroy()
    end
end)

coroutine.resume(msg)
end)
BT("Kill All", function()
	RequestCommandSilent:InvokeServer(";kill all")
end)
BT("become thomas", function()
	local player = game.Players.LocalPlayer
	local char = player.Character
	local tool
	for i,v in player:GetDescendants() do
		if v.Name == "SyncAPI" then
			tool = v.Parent
		end
	end
	for i,v in game.ReplicatedStorage:GetDescendants() do
		if v.Name == "SyncAPI" then
			tool = v.Parent
		end
	end
	--craaa
	remote = tool.SyncAPI.ServerEndpoint
	function _(args)
		remote:InvokeServer(unpack(args))
	end
	function SetCollision(part,boolean)
		local args = {
			[1] = "SyncCollision",
			[2] = {
				[1] = {
					["Part"] = part,
					["CanCollide"] = boolean
				}
			}
		}
		_(args)
	end
	function SetAnchor(boolean,part)
		local args = {
			[1] = "SyncAnchor",
			[2] = {
				[1] = {
					["Part"] = part,
					["Anchored"] = boolean
				}
			}
		}
		_(args)
	end
	function CreatePart(cf,parent)
		local args = {
			[1] = "CreatePart",
			[2] = "Normal",
			[3] = cf,
			[4] = parent
		}
		_(args)
	end
	function DestroyPart(part)
		local args = {
			[1] = "Remove",
			[2] = {
				[1] = part
			}
		}
		_(args)
	end
	function MovePart(part,cf)
		local args = {
			[1] = "SyncMove",
			[2] = {
				[1] = {
					["Part"] = part,
					["CFrame"] = cf
				}
			}
		}
		_(args)
	end
	function Resize(part,size,cf)
		local args = {
			[1] = "SyncResize",
			[2] = {
				[1] = {
					["Part"] = part,
					["CFrame"] = cf,
					["Size"] = size
				}
			}
		}
		_(args)
	end
	function AddMesh(part)
		local args = {
			[1] = "CreateMeshes",
			[2] = {
				[1] = {
					["Part"] = part
				}
			}
		}
		_(args)
	end

	function SetMesh(part,meshid)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["MeshId"] = "rbxassetid://"..meshid
				}
			}
		}
		_(args)
	end
	function SetTexture(part, texid)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["TextureId"] = "rbxassetid://"..texid
				}
			}
		}
		_(args)
	end
	function SetName(part, stringg)
		local args = {
			[1] = "SetName",
			[2] = {
				[1] = workspace.Part
			},
			[3] = stringg
		}

		_(args)
	end
	function MeshResize(part,size)
		local args = {
			[1] = "SyncMesh",
			[2] = {
				[1] = {
					["Part"] = part,
					["Scale"] = size
				}
			}
		}
		_(args)
	end
	function Weld(part1, part2,lead)
		local args = {
			[1] = "CreateWelds",
			[2] = {
				[1] = part1,
				[2] = part2
			},
			[3] = lead
		}
		_(args)

	end
	function SetLocked(part,boolean)
		local args = {
			[1] = "SetLocked",
			[2] = {
				[1] = part
			},
			[3] = boolean
		}
		_(args)
	end
	function SetTrans(part,int)
		local args = {
			[1] = "SyncMaterial",
			[2] = {
				[1] = {
					["Part"] = part,
					["Transparency"] = int
				}
			}
		}
		_(args)
	end
	function CreateSpotlight(part)
		local args = {
			[1] = "CreateLights",
			[2] = {
				[1] = {
					["Part"] = part,
					["LightType"] = "SpotLight"
				}
			}
		}
		_(args)
	end
	function SyncLighting(part,brightness)
		local args = {
			[1] = "SyncLighting",
			[2] = {
				[1] = {
					["Part"] = part,
					["LightType"] = "SpotLight",
					["Brightness"] = brightness
				}
			}
		}
		_(args)
	end
	local player = game.Players.LocalPlayer
	local char = player.Character

	function xd()
		spawn(function()
			local args = {
				[1] = "SyncMaterial",
				[2] = {
					[1] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character.Torso,
						["Transparency"] = 1
					},
					[2] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character:FindFirstChild("Left Leg"),
						["Transparency"] = 1
					},
					[3] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart,
						["Transparency"] = 1
					},
					[4] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character:FindFirstChild("Right Leg"),
						["Transparency"] = 1
					},
					[5] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character:FindFirstChild("Right Arm"),
						["Transparency"] = 1
					},
					[6] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character:FindFirstChild("Left Arm"),
						["Transparency"] = 1
					},
					[7] = {
						["Part"] = game:GetService("Players").LocalPlayer.Character.Head,
						["Transparency"] = 1
					},
				}
			}

			_(args)

		end)
	end

	function Thomas(player)
		SetAnchor(true,char.HumanoidRootPart)
		CreatePart(char.HumanoidRootPart.CFrame,char,"Normal")
		SetCollision(char.Part,false)
		SetLocked(char.Part,false)
		Resize(char.Part,Vector3.new(5,5,10),char.HumanoidRootPart.CFrame)
		CreateSpotlight(char.Part)
		SyncLighting(char.Part,100)
		SetLocked(char.HumanoidRootPart,false)
		Weld(char.Part,char.HumanoidRootPart,char.Part)
		SetAnchor(false,char.Part)
		AddMesh(char.Part)
		MeshResize(char.Part,Vector3.new(2,2,1.5))
		SetMesh(char.Part,"2231280549")
		SetTexture(char.Part,"2231280614")
		SetAnchor(false,char.HumanoidRootPart)
		char.Humanoid.WalkSpeed = 80
		local function SFX(id) local s=Instance.new("Sound",char.Torso); s.SoundId = "rbxassetid://"..id; s.Volume = 1; return s; end
		char.Part.Touched:connect(function(p)
			if p.Parent then
				if p.Parent:IsA("Model") then
					if game.Players:FindFirstChild(p.Parent.Name) then
						if p.Parent.Name ~= game.Players.LocalPlayer.Name then
							spawn(function()
								DestroyPart(game.Players:FindFirstChild(p.Parent.Name).Character.Head)
							end)
							local Whistle = SFX(475073913)
							Whistle:Play()
						end
					end
				end
			end
		end)

		local Music = SFX(0)
		Music.Pitch = 1.15
		Music:Play()

		game:GetService("RunService").RenderStepped:Connect(function()
			for i,v in char:GetDescendants() do
				if v:IsA("BasePart") then
					char.Humanoid.WalkSpeed = 80
					v.CanCollide = false
				end
			end
		end)
	end
	Thomas(player)
	xd()
end)
BT("Explode random", function()
	local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player.Backpack

-- Get F3X
local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	for _, v in ipairs(char:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then return v end
	end
	return nil
end

local f3x = getf3x()
if not f3x then
	warn("No F3X found!")
	return
end

local remote = f3x.SyncAPI.ServerEndpoint
local function invokeServer(...)
	return remote:InvokeServer(...)
end

-- Helpers
local function createPart(cf)
	return invokeServer("CreatePart", "Normal", cf, workspace)
end

local function resize(part, size)
	invokeServer("SyncResize", {{Part = part, CFrame = part.CFrame, Size = size}})
end

local function color(part, color3)
	invokeServer("SyncColor", {{Part = part, Color = color3, UnionColoring = false}})
end

local function addFire(part, size, heat)
	invokeServer("CreateDecorations", {{Part = part, DecorationType = "Fire"}})
	invokeServer("SyncDecorate", {{
		Part = part,
		DecorationType = "Fire",
		Size = size,    -- BIGGER FIRE SIZE
		Heat = heat     -- HOTTER FIRE
	}})
end

local function addLight(part, brightness, color)
	invokeServer("CreateLights", {{Part = part, LightType = "PointLight"}})
	invokeServer("SyncLighting", {{
		Part = part,
		LightType = "PointLight",
		Brightness = brightness,
		Color = color
	}})
end

local function anchor(part, anchored)
	invokeServer("SyncAnchor", {{Part = part, Anchored = anchored}})
end

local function destroy(part)
	invokeServer("Remove", {part})
end

-- Explosion fireball (NO visible cube)
local function spawnFireball(pos)
	local part = createPart(CFrame.new(pos))
	if not part then return end
	
	-- Make it tiny & black so itâ€™s invisible
	resize(part, Vector3.new(0.1, 0.1, 0.1))
	color(part, Color3.new(0,0,0))
	anchor(part, true)
	
	-- BIG fireball + intense heat
	addFire(part, 80, 100)         -- way bigger than default
	addLight(part, 50, Color3.new(1, 0.4, 0)) -- bright flash
	
	-- Remove quickly for flash effect
	task.delay(0.4, function()
		destroy(part)
	end)
end

-- Loop: many random fireballs around player
local root = char:WaitForChild("HumanoidRootPart")

while task.wait(0.08) do
	for _ = 1, 6 do
		task.spawn(function()
			local x = root.Position.X + math.random(-300, 300)
			local y = root.Position.Y + math.random(100, 400)
			local z = root.Position.Z + math.random(-300, 300)
			spawnFireball(Vector3.new(x, y, z))
		end)
	end
end
end)
BT("raining fire", function()
	local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- Locate SyncAPI tool
local tool
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

if not tool then
    warn("No F3X tool found!")
    return
end

local remote = tool.SyncAPI.ServerEndpoint
local function call(args)
    remote:InvokeServer(unpack(args))
end

-- F3X helpers
local function CreatePart(cf)
    return remote:InvokeServer("CreatePart", "Normal", cf, workspace)
end

local function Resize(part, size)
    call({"SyncResize", {{Part = part, CFrame = part.CFrame, Size = size}}})
end

local function SetShape(part, shape)
    call({"SyncShape", {{Part = part, Shape = shape}}})
end

local function SetCollision(part, bool)
    call({"SyncCollision", {{Part = part, CanCollide = bool}}})
end

local function Anchor(part, bool)
    call({"SyncAnchor", {{Part = part, Anchored = bool}}})
end

local function AddFire(part)
    call({"CreateDecorations", {{Part = part, DecorationType = "Fire"}}})
    call({"SyncDecorate", {{
        Part = part,
        DecorationType = "Fire",
        Size = 25,
        Heat = 30
    }}})
end

local function SetColor(part, color3)
    call({"SyncColor", {{
        Part = part,
        Color = color3,
        UnionColoring = false
    }}})
end

-- Fire rain loop
local root = char:WaitForChild("HumanoidRootPart")

while task.wait(0.25) do
    -- Random position above player
    local x = root.Position.X + math.random(-300, 300)
    local z = root.Position.Z + math.random(-300, 300)
    local y = root.Position.Y + math.random(250, 500)
    local cf = CFrame.new(x, y, z)

    task.spawn(function()
        -- Create part and get reference
        local newPart = CreatePart(cf)
        task.wait(0.2) -- allow part to exist
        
        -- Find the new part near spawn location
        for _, v in workspace:GetChildren() do
            if v:IsA("Part") and (v.Position - cf.Position).Magnitude < 5 then
                -- Make it a meteor fireball
                Resize(v, Vector3.new(10, 10, 10)) -- medium meteor size
                SetShape(v, Enum.PartType.Ball)
                SetColor(v, Color3.new(0, 0, 0)) -- BLACK meteor
                AddFire(v)

                -- âœ… Let gravity drop it, and let it HIT the ground
                SetCollision(v, true)   -- collide with floor
                Anchor(v, false)        -- unanchored so it falls
                
                break
            end
        end
    end)
end
end)
BT("Destroy. [ONLY FOR EMERGENCY]", function()
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- HDAdmin RequestCommand (global)
-- ===============================
local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
pcall(function()
    RequestCommand:InvokeServer(";btools me")
    RequestCommand:InvokeServer(";fogcolor black")
    task.wait(0.4)
    RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) detection
-- ===============================
local backpack = player.Backpack
local function getf3x()
    for _, v in ipairs(backpack:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    for _, v in ipairs(char:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then return v end
    end
    return nil
end

local f3x = getf3x()
if not f3x then
    warn("You don't have F3X")
    return
end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Fast parallel invoke
local function fastInvoke(args)
    task.spawn(function()
        pcall(function()
            serverendpoint:InvokeServer(unpack(args))
        end)
    end)
end

-- Delete part helper
local function delete(part)
    fastInvoke({"Remove",{part}})
end

-- ===============================
-- FAST DELETE EVERYTHING
-- ===============================
for _, v in ipairs(workspace:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("UnionOperation") then
        task.spawn(function()
            pcall(function() delete(v) end)
        end)
    end
end

print("All parts deleted (fast).")

-- ===============================
-- Helper wrappers
-- ===============================
local function _(args) serverendpoint:InvokeServer(unpack(args)) end
local function MovePart(part, cf) _( {"SyncMove", { { Part = part, CFrame = cf } } } ) end
local function resize(part, size, cf) _( {"SyncResize", { { Part = part, CFrame = cf, Size = size } } } ) end
local function transparency(part, trans) _( {"SyncMaterial", { { Part = part, Transparency = trans } } } ) end
local function color(part, color3) _( {"SyncColor", { { Part = part, Color = color3, UnionColoring = false } } } ) end
local function makemesh(part) _( {"CreateMeshes", { { Part = part } } } ) end
local function syncmeshid(part, id) _( {"SyncMesh", { { Part = part, MeshId = "rbxassetid://"..id } } } ) end
local function syncmeshsize(part, size) _( {"SyncMesh", { { Part = part, Scale = size } } } ) end
local function syncmeshtexture(part, id) _( {"SyncMesh", { { Part = part, TextureId = "rbxassetid://"..id } } } ) end
local function name(part, str) _( {"SetName", { part }, str} ) end
local function createtexture(part, face) _( {"CreateTextures", { { Part = part, Face = face, TextureType = "Texture" } } } ) end
local function createdecal(part, face) _( {"CreateTextures", { { Part = part, Face = face, TextureType = "Decal" } } } ) end
local function setdecal(part, asset, face) _( {"SyncTexture", { { Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset } } } ) end
local function floor(part, face) _( {"SyncTexture", { { Part = part, Face = face, TextureType = "Texture", Texture = "rbxassetid://135172958780980", StudsPerTileV = 2, StudsPerTileU = 2 } } } ) end

-- Simple CreatePart wrapper
local function CreatePart(cf, parent, ptype)
    return serverendpoint:InvokeServer("CreatePart", ptype or "Normal", cf, parent or workspace)
end

-- ===============================
-- Sky generator
-- ===============================
local function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local cf = CFrame.new(math.floor(hrp.Position.X), math.floor(hrp.Position.Y), math.floor(hrp.Position.Z)) + Vector3.new(0,6,0)
    local skyPart = CreatePart(cf, workspace)
    name(skyPart,"Sky")
    makemesh(skyPart)
    syncmeshid(skyPart,"111891702759441")
    syncmeshtexture(skyPart,id)
    syncmeshsize(skyPart,Vector3.new(90000,90000,90000))
end

-- ===============================
-- Realm Builder V2
-- ===============================
local function RealmV2()
    local position = CFrame.new(-152.421, -46.197, -115.697)
    local base = CreatePart(position, workspace)
    resize(base, Vector3.new(869, 1, 543), position)
    color(base, Color3.fromRGB(71, 101, 76))
    createtexture(base, Enum.NormalId.Top)
    floor(base, Enum.NormalId.Top)

    local spawnpos = CFrame.new(42.125, -45.697, -48.895)
    local spawna = CreatePart(spawnpos, workspace, "Spawn")
    resize(spawna, Vector3.new(6, 1, 6), spawnpos)
    name(spawna, "SpawnLocation")
    createdecal(spawna, Enum.NormalId.Top)
    setdecal(spawna, "108356843475171", Enum.NormalId.Top)

    local wall = CFrame.new(64.885, -40.197, -74.988)
    local base2 = CreatePart(wall, workspace)
    resize(base2, Vector3.new(27, 12, 1), wall)
    transparency(base2, 1)
    createdecal(base2, Enum.NormalId.Back)
    setdecal(base2, "130387609774454", Enum.NormalId.Back)

    local pos1 = CFrame.new(49.037, -42.797, -75.077)
    local obj1 = CreatePart(pos1, workspace)
    makemesh(obj1)
    syncmeshid(obj1, "7879233630")
    syncmeshtexture(obj1, "113929343766399")
    MovePart(obj1, obj1.CFrame * CFrame.Angles(0, math.rad(180), 0))

    local pos2 = CFrame.new(36.46, -45.197, -76.523)
    local obj2 = CreatePart(pos2, workspace)
    makemesh(obj2)
    syncmeshid(obj2, "13846055645")
    syncmeshtexture(obj2, "13846055859")
    syncmeshsize(obj2, Vector3.new(5, 5, 5))
    MovePart(obj2, obj2.CFrame * CFrame.Angles(0, math.rad(90), 0))

    local pos3 = CFrame.new(35.793, -32.697, -104.497)
    local obj3 = CreatePart(pos3, workspace)
    makemesh(obj3)
    syncmeshid(obj3, "7879233630")
    syncmeshtexture(obj3, "125929634799364")
    syncmeshsize(obj3, Vector3.new(5, 5, 5))
    MovePart(obj3, obj3.CFrame * CFrame.Angles(0, math.rad(180), 0))

    local pos4 = CFrame.new(35.753, -19.697, -104.15)
    local obj4 = CreatePart(pos4, workspace)
    makemesh(obj4)
    syncmeshid(obj4, "5924046624")
    syncmeshtexture(obj4, "5924037225")
    syncmeshsize(obj4, Vector3.new(3, 3, 3))
end

-- ===============================
-- Main Execution
-- ===============================
local function realm()
    RealmV2()
    Sky("9820931824")
end

realm()

-- Final HDAdmin
pcall(function()
    RequestCommand:InvokeServer(";fogcolor black ;time")
    task.wait(0.2)
    RequestCommand:InvokeServer(";res all")
    task.wait(0.2)
    RequestCommand:InvokeServer(";r6 all")
    task.wait(0.2)
    RequestCommand:InvokeServer(";time 14")
task.wait(1.7)
RequestCommandSilent:InvokeServer(";music 1839246711 ;volume inf")
end)
end)
BT("KaaX Script", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";time 0")
SilentRequest:InvokeServer(";fogcolor black")
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Locate SyncAPI tool
for _, v in player:GetDescendants() do
	if v.Name == "SyncAPI" then
		tool = v.Parent
	end
end
for _, v in game.ReplicatedStorage:GetDescendants() do
	if v.Name == "SyncAPI" then
		tool = v.Parent
	end
end

local remote = tool.SyncAPI.ServerEndpoint

-- Silent remote call wrapper
local function _(args)
	remote:InvokeServer(unpack(args))
end

-- === Utility Functions ===
local function CreatePart(cf, parent)
	_({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
	_({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
	_({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
	_({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
	_({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
	_({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
	_({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetLocked(part, state)
	_({"SetLocked", {part}, state})
end

local function SpawnDecal(part, side)
	_({"CreateTextures", {{Part = part, Face = side, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, side)
	_({"SyncTexture", {{Part = part, Face = side, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})
end

-- === Normal Sky Function (smaller) ===
local function Sky(id)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local cf = hrp.CFrame
	local pos = cf.Position + Vector3.new(0, 6, 0)
	CreatePart(CFrame.new(pos), workspace)
	task.wait(0.3) -- tiny delay for the part to exist
	for _, v in workspace:GetDescendants() do
		if v:IsA("BasePart") and (v.Position - pos).Magnitude < 0.1 then
			SetAnchor(v, true)
			AddMesh(v)
			SetMesh(v, "111891702759441")
			SetTexture(v, id)
			MeshResize(v, Vector3.new(8000, 8000, 8000))
		end
	end
end

-- === Giant Skybox Function ===
local function GiantSky(id)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local cf = hrp.CFrame
	local pos = cf.Position + Vector3.new(0, 6, 0)

	-- Create base part
	CreatePart(CFrame.new(pos), workspace)
	task.wait(0.3)

	for _, v in workspace:GetDescendants() do
		if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
			SetAnchor(v, true)
			AddMesh(v)
			SetMesh(v, "111891702759441") -- sphere/dome
			SetTexture(v, id)
			MeshResize(v, Vector3.new(90000, 90000, 90000)) -- massive size
			SetCollision(v, false)
			SetLocked(v, true)
		end
	end
end

-- === Spam Decals Function ===
local function Spam(id)
	for _, v in workspace:GetDescendants() do
		if v:IsA("BasePart") then
			task.spawn(function()
				SetLocked(v, false)
				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
					SpawnDecal(v, side)
					AddDecal(v, id, side)
				end
			end)
		end
	end
end

-- === Call Functions ===
GiantSky("5151897861") -- giant skybox
Spam("12330950245") -- spam decals

end)
BT("Shedletsky", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";time 0")
SilentRequest:InvokeServer(";fogcolor black")
--// SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Try to find SyncAPI in player first
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end
-- If not found, check ReplicatedStorage
if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end
if not tool then
    error("SyncAPI tool not found")
end

local remote = tool.SyncAPI.ServerEndpoint

--// Simple remote call wrapper
local function _(args)
    remote:InvokeServer(unpack(args))
end

--// Helper functions
local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end
local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end
local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end
local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end
local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end
local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end
local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end
local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end
local function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end
local function SpawnDecal(part, face)
    _({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end
local function AddDecal(part, asset, face)
    _({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset}}})
end
local function SetName(part, name)
    _({"SetName", {part}, name})
end
local function SetTrans(part, val)
    _({"SyncMaterial", {{Part = part, Transparency = val}}})
end
local function delete(part)
    _({"Remove", {part}})
end

--// === Giant Sky Function ===
local function GiantSky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local pos = hrp.Position + Vector3.new(0, 6, 0)

    CreatePart(CFrame.new(pos), workspace)  
    task.wait(0.3)  

    for _, v in workspace:GetDescendants() do  
        if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then  
            SetAnchor(v, true)  
            AddMesh(v)  
            SetMesh(v, "111891702759441") -- sphere mesh  
            SetTexture(v, id)  
            MeshResize(v, Vector3.new(90000, 90000, 90000))  
            SetCollision(v, false)  
            SetLocked(v, true)  
        end  
    end
end

--// === Improved Particle Effect System ===
local activeParticles = {}
local particleCooldowns = {}

local function createParticleForPlayer(targetPlayer, textureId)
    -- Wait for character to load
    local character = targetPlayer.Character
    if not character then
        targetPlayer.CharacterAdded:Wait()
        character = targetPlayer.Character
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local playerKey = targetPlayer.UserId
    
    -- Initialize cooldown for this player/texture combination
    local cooldownKey = playerKey .. "_" .. textureId
    particleCooldowns[cooldownKey] = particleCooldowns[cooldownKey] or 0
    
    while true do
        local currentTime = tick()
        
        -- Check cooldown (2 seconds between particles)
        if currentTime - particleCooldowns[cooldownKey] >= 2 then
            particleCooldowns[cooldownKey] = currentTime
            
            -- Check if player and character are still valid
            if not targetPlayer or not targetPlayer.Parent or not character or not character.Parent or humanoid.Health <= 0 then
                break
            end
            
            local head = character:FindFirstChild("Head")
            if not head then
                task.wait(1)
                continue
            end

            -- Spawn particle above head
            local spawnCFrame = head.CFrame + Vector3.new(0, 3, 0)
            
            task.spawn(function()  
                CreatePart(spawnCFrame, workspace)  
                task.wait(0.1)  
                
                local newPart = nil
                for _, v in workspace:GetChildren() do  
                    if v:IsA("Part") and (v.Position - spawnCFrame.Position).Magnitude < 1 then  
                        newPart = v
                        break
                    end  
                end
                
                if newPart then
                    SetName(newPart, "particle_" .. targetPlayer.Name .. "_" .. textureId)  
                    Resize(newPart, Vector3.new(6, 6, 0.001), newPart.CFrame)  
                    SetCollision(newPart, false)  
                    SetTrans(newPart, 1)  
                    SetAnchor(newPart, true)  
                    newPart.Orientation = Vector3.new(0, 0, 0)  

                    SpawnDecal(newPart, Enum.NormalId.Front)  
                    AddDecal(newPart, textureId, Enum.NormalId.Front)  
                    SpawnDecal(newPart, Enum.NormalId.Back)  
                    AddDecal(newPart, textureId, Enum.NormalId.Back)  

                    -- Track this particle
                    local particleId = #activeParticles + 1
                    activeParticles[particleId] = newPart

                    -- Animate particle rising up
                    for i = 1, 40 do  -- Reduced frames for faster cleanup
                        if newPart and newPart.Parent and head and head.Parent then  
                            local currentHeadPos = head.Position
                            local newPosition = Vector3.new(
                                currentHeadPos.X,
                                spawnCFrame.Position.Y + (i * 2),  -- Move up 2 studs per frame
                                currentHeadPos.Z
                            )
                            local newCFrame = CFrame.new(newPosition)
                            Resize(newPart, newPart.Size, newCFrame)  
                            task.wait(0.05)  -- Slightly faster animation
                        else
                            break
                        end
                    end  
                    
                    -- Cleanup
                    if newPart and newPart.Parent then
                        delete(newPart)  
                    end
                    activeParticles[particleId] = nil
                end  
            end)  
        end
        
        task.wait(0.5) -- Check every 0.5 seconds instead of 0.1
    end
end

--// === Manage Particles for All Players ===
local function startParticleSystem()
    local textureIds = {"85312612489831"}
    local activeConnections = {}
    
    -- Function to start particles for a specific player
    local function startForPlayer(player)
        for _, texId in ipairs(textureIds) do
            coroutine.wrap(function()
                createParticleForPlayer(player, texId)
            end)()
        end
    end
    
    -- Function to stop particles for a specific player
    local function stopForPlayer(player)
        -- Clean up any particles for this player
        for particleId, part in pairs(activeParticles) do
            if part.Name:find(player.Name) and part.Parent then
                delete(part)
                activeParticles[particleId] = nil
            end
        end
    end
    
    -- Start particles for all current players
    for _, existingPlayer in ipairs(Players:GetPlayers()) do
        startForPlayer(existingPlayer)
    end
    
    -- Listen for new players
    Players.PlayerAdded:Connect(function(newPlayer)
        startForPlayer(newPlayer)
    end)
    
    -- Listen for players leaving
    Players.PlayerRemoving:Connect(function(leavingPlayer)
        stopForPlayer(leavingPlayer)
    end)
end

--// === Cleanup System ===
local function setupCleanup()
    -- Periodic cleanup of any orphaned particles
    while true do
        task.wait(10) -- Clean up every 10 seconds
        for particleId, part in pairs(activeParticles) do
            if not part or not part.Parent then
                activeParticles[particleId] = nil
            end
        end
    end
end

--// === Run Both Effects ===
GiantSky("172423468") -- your sky texture asset ID
startParticleSystem()
coroutine.wrap(setupCleanup)()

end)
BT("c00lify", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";unfog")
SilentRequest:InvokeServer(";time 0")
SilentRequest:InvokeServer(";fogcolor black")
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Locate SyncAPI tool
for _, v in player:GetDescendants() do
	if v.Name == "SyncAPI" then
		tool = v.Parent
	end
end
for _, v in game.ReplicatedStorage:GetDescendants() do
	if v.Name == "SyncAPI" then
		tool = v.Parent
	end
end

local remote = tool.SyncAPI.ServerEndpoint

-- Silent remote call wrapper
local function _(args)
	remote:InvokeServer(unpack(args))
end

-- === Utility Functions ===
local function CreatePart(cf, parent)
	_({"CreatePart", "Normal", cf, parent})
end

local function SetAnchor(part, state)
	_({"SyncAnchor", {{Part = part, Anchored = state}}})
end

local function SetCollision(part, state)
	_({"SyncCollision", {{Part = part, CanCollide = state}}})
end

local function AddMesh(part)
	_({"CreateMeshes", {{Part = part}}})
end

local function SetMesh(part, meshid)
	_({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end

local function SetTexture(part, texid)
	_({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end

local function MeshResize(part, size)
	_({"SyncMesh", {{Part = part, Scale = size}}})
end

local function SetLocked(part, state)
	_({"SetLocked", {part}, state})
end

local function SpawnDecal(part, side)
	_({"CreateTextures", {{Part = part, Face = side, TextureType = "Decal"}}})
end

local function AddDecal(part, asset, side)
	_({"SyncTexture", {{Part = part, Face = side, TextureType = "Decal", Texture = "rbxassetid://" .. asset}}})
end

-- === Normal Sky Function (smaller) ===
local function Sky(id)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local cf = hrp.CFrame
	local pos = cf.Position + Vector3.new(0, 6, 0)
	CreatePart(CFrame.new(pos), workspace)
	task.wait(0.3) -- tiny delay for the part to exist
	for _, v in workspace:GetDescendants() do
		if v:IsA("BasePart") and (v.Position - pos).Magnitude < 0.1 then
			SetAnchor(v, true)
			AddMesh(v)
			SetMesh(v, "111891702759441")
			SetTexture(v, id)
			MeshResize(v, Vector3.new(8000, 8000, 8000))
		end
	end
end

-- === Giant Skybox Function ===
local function GiantSky(id)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local cf = hrp.CFrame
	local pos = cf.Position + Vector3.new(0, 6, 0)

	-- Create base part
	CreatePart(CFrame.new(pos), workspace)
	task.wait(0.3)

	for _, v in workspace:GetDescendants() do
		if v:IsA("BasePart") and (v.Position - pos).Magnitude < 1 then
			SetAnchor(v, true)
			AddMesh(v)
			SetMesh(v, "111891702759441") -- sphere/dome
			SetTexture(v, id)
			MeshResize(v, Vector3.new(90000, 90000, 90000)) -- massive size
			SetCollision(v, false)
			SetLocked(v, true)
		end
	end
end

-- === Spam Decals Function ===
local function Spam(id)
	for _, v in workspace:GetDescendants() do
		if v:IsA("BasePart") then
			task.spawn(function()
				SetLocked(v, false)
				for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
					SpawnDecal(v, side)
					AddDecal(v, id, side)
				end
			end)
		end
	end
end

-- === Call Functions ===
GiantSky("5151897861") -- giant skybox
Spam("158118263") -- spam decals
end)

BT("John Doe [R6]", function()
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Track if script should be active
local scriptActive = true
local inputConnection
local descendantConnection

-- Function to completely stop the script
local function disableScript()
    scriptActive = false
    if inputConnection then
        inputConnection:Disconnect()
    end
    if descendantConnection then
        descendantConnection:Disconnect()
    end
end

for i,v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
for i,v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

remote = tool.SyncAPI.ServerEndpoint
function _(args)
    remote:InvokeServer(unpack(args))
end

local function Color(part, color)
    local args = {
        "SyncColor",
        {
            {
                Part = part,
                Color = color,
                UnionColoring = false
            }
        }
    }
    _(args)
end

local function applyDecorationToPart(part)
    local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire"
            }
        }
    }
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire",
                ["Size"] = 3,
                ["Heat"] = 25,
                ["Color"] = Color3.fromRGB(255, 0, 0),
                ["SecondaryColor"] = Color3.fromRGB(255, 0, 0)
            }
        }
    }
    _(argsCreate)
    _(argsSync)
end

local function Parter(part)
    local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Smoke"
            }
        }
    }
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Smoke",
                ["Size"] = 3,
                ["Color"] = Color3.fromRGB(255, 0, 0),
            }
        }
    }
    _(argsCreate)
    _(argsSync)
end

local function eyePart(part)
    local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire"
            }
        }
    }
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire",
                ["Size"] = 1,
                ["Heat"] = 12,
                ["Color"] = Color3.fromRGB(155, 0, 0),
                ["SecondaryColor"] = Color3.fromRGB(255, 0, 0)
            }
        }
    }
    _(argsCreate)
    _(argsSync)
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandModification

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Apply character setup
RequestCommand:InvokeServer(";removeaccessories")
RequestCommand:InvokeServer(";titlebk me John Doe")
wait(1)
RequestCommand:InvokeServer(";hat me 107676946962151")
wait(0.9)
RequestCommand:InvokeServer(";hat me 18196403126")
wait(1)
RequestCommand:InvokeServer(";hat me 18801497637")
wait(1)
RequestCommand:InvokeServer(";shirt me 100276101149100")
wait(1)
RequestCommand:InvokeServer(";head me 0")
RequestCommand:InvokeServer(";face me 144075659")
wait(1)
RequestCommand:InvokeServer(";shirt me 100276101149100")
RequestCommand:InvokeServer(";pants me 109662040845019")
wait(1.8)
RequestCommand:InvokeServer(";time 0")

local eye = char:FindFirstChild("Accessory (JohnEye)").Handle
local arm = char:FindFirstChild("Right Arm")
local tor = char:FindFirstChild("Torso")
local ar2 = char:FindFirstChild("Left Arm")
local RLeg = char:FindFirstChild("Right Leg")
local head = char:FindFirstChild("Head")
local LLeg = char:FindFirstChild("Left Leg")

applyDecorationToPart(arm)
applyDecorationToPart(ar2)
eyePart(eye)
Parter(tor)

Color(arm, Color3.fromRGB(252, 255, 150))
Color(ar2, Color3.fromRGB(252, 255, 150))
Color(head, Color3.fromRGB(252, 255, 150))
Color(tor, Color3.fromRGB(255, 255, 0))
Color(RLeg, Color3.fromRGB(0, 200, 255))
Color(LLeg, Color3.fromRGB(0, 200, 255))

local arm = character:FindFirstChild("Right Arm")
local humanoid = character:FindFirstChildOfClass("Humanoid")

-- Detect when character is removed (happens during respawn)
player.CharacterRemoving:Connect(function()
    disableScript()
end)

humanoid.Died:Connect(function()
    disableScript()
end)

local animator = humanoid:FindFirstChildOfClass("Animator")
local attackAnim = Instance.new("Animation")
attackAnim.AnimationId = "rbxassetid://186934658"
local attackTrack = animator:LoadAnimation(attackAnim)

function KillTarget(target)
    if not scriptActive then return end
    if target and target.Character then
        local head = target.Character:FindFirstChild("Head")
        if head then
            local args = {
                [1] = "SetLocked",
                [2] = {
                    [1] = head
                },
                [3] = false
            }
            remote:InvokeServer(unpack(args))
            task.wait(0.1)
            local args2 = {
                [1] = "Remove",
                [2] = {
                    [1] = head
                }
            }
            remote:InvokeServer(unpack(args2))
        end
    end
end

local function attack()
    if not scriptActive then return end
    attackTrack:Play()
    local hitPlayer = nil
    local touchedConnection

    local function onTouch(other)
        if not scriptActive then return end
        local otherPlayer = Players:GetPlayerFromCharacter(other.Parent)
        if otherPlayer and otherPlayer ~= player then
            hitPlayer = otherPlayer
        end
    end

    touchedConnection = arm.Touched:Connect(onTouch)
    task.wait(0.5)
    if touchedConnection then
        touchedConnection:Disconnect()
    end
    if hitPlayer then
        RequestCommand:InvokeServer(";music 82500396906354 ;volume 0.5")
        KillTarget(hitPlayer)
        task.wait(1)
        RequestCommand:InvokeServer(";unmusic")
    else
        RequestCommand:InvokeServer(";music 28144425 ;pitch 0.6 ;volume 7")
        task.wait(0.8)
        RequestCommand:InvokeServer(";unmusic")
    end
end

-- === Input Replacement ===
local canAttack = true
local function attackWithCooldown()
    if not scriptActive or not canAttack then return end
    canAttack = false
    attack()
    task.delay(2.2, function()
        canAttack = true
    end)
end

inputConnection = UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if not scriptActive then 
        return 
    end
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        attackWithCooldown()
    end
end)

-- === F3X Utility Functions ===
local player = game.Players.LocalPlayer
local char = player.Character
local backpack = player.Backpack

local function getf3x()
    for _, v in ipairs(backpack:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then
            return v
        end
    end
    for _, v in ipairs(char:GetChildren()) do
        if v:FindFirstChild("SyncAPI") then
            return v
        end
    end
    return nil
end

local f3x = getf3x()
if not f3x then
    warn("you dont have f3x skid")
end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

function _(args)
    serverendpoint:InvokeServer(unpack(args))
end

local function fire(part)
    local argsCreate = {
        [1] = "CreateDecorations",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire"
            }
        }
    }
    local argsSync = {
        [1] = "SyncDecorate",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["DecorationType"] = "Fire",
                ["Size"] = 15,
                ["Heat"] = 15,
                ["Color"] = Color3.fromRGB(255, 0, 0),
                ["SecondaryColor"] = Color3.fromRGB(255, 0, 0)
            }
        }
    }
    _(argsCreate)
    _(argsSync)
end

function delete(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

function MovePart(part, cf)
    local args = {
        "SyncMove",
        {
            {
                Part = part,
                CFrame = cf
            }
        }
    }
    _(args)
end

local function resize(part, size, cf)
    local args = {
        "SyncResize",
        {
            {
                Part = part,
                CFrame = cf,
                Size = size
            }
        }
    }
    _(args)
end

local function syncmaterial(part, mate)
    local args = {
        "SyncMaterial",
        {
            {
                Part = part,
                Material = mate
            }
        }
    }
    _(args)
end

local function transparency(part, trans)
    local args = {
        "SyncMaterial",
        {
            {
                Part = part,
                Transparency = trans
            }
        }
    }
    _(args)
end

local function color(part, color)
    local args = {
        "SyncColor",
        {
            {
                Part = part,
                Color = color,
                UnionColoring = false
            }
        }
    }
    _(args)
end

local function syncmeshid(part, id)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                MeshId = "rbxassetid://" .. id
            }
        }
    }
    _(args)
end

function destroy(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

local function makemesh(part)
    local args = {
        "CreateMeshes",
        {
            {
                Part = part
            }
        }
    }
    _(args)
end

local function syncmeshsize(part, vectora)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                Scale = vectora
            }
        }
    }
    _(args)
end

local function syncmeshtexture(part, id)
    local args = {
        "SyncMesh",
        {
            {
                Part = part,
                TextureId = "rbxassetid://" .. id
            }
        }
    }
    _(args)
end

local function name(part, stringa)
    local args = {
        "SetName",
        { part },
        stringa
    }
    _(args)
end

local function lock(part, boolean)
    local args = {
        "SetLocked",
        { part },
        boolean
    }
    _(args)
end

local function setcollision(part, booleana)
    local args = {
        "SyncCollision",
        {
            {
                Part = part,
                CanCollide = booleana
            }
        }
    }
    _(args)
end

local function setanchor(part, boolean)
    local args = {
        "SyncAnchor",
        {
            {
                Part = part,
                Anchored = boolean
            }
        }
    }
    _(args)
end

local function createdecal(part, side)
    local args = {
        "CreateTextures",
        {
            {
                Part = part,
                Face = side,
                TextureType = "Decal"
            }
        }
    }
    _(args)
end

local function setdecal(part, asset, side)
    local args = {
        "SyncTexture",
        {
            {
                Part = part,
                Face = side,
                TextureType = "Decal",
                Texture = "rbxassetid://" .. asset
            }
        }
    }
    _(args)
end

-- ===== LIGHTING SYSTEM =====
local function addlight(part)
    local args = {
        [1] = "CreateLights",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["LightType"] = "PointLight"
            }
        }
    }
    serverendpoint:InvokeServer(unpack(args))
end

local function synclight(part, brightness, range)
    local args = {
        [1] = "SyncLighting",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["LightType"] = "PointLight",
                ["Brightness"] = brightness,
                ["Range"] = range,
                ["Color"] = Color3.new(0.35, 0, 0)
            }
        }
    }
    serverendpoint:InvokeServer(unpack(args))
end

-- Apply lights to all existing parts
for _, v in ipairs(workspace:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("UnionOperation") then
        task.spawn(function()
            addlight(v)
            synclight(v, 0.2, 35)
        end)
    end
end

-- Apply lights to new parts as they're added
descendantConnection = workspace.DescendantAdded:Connect(function(descendant)
    if descendant:IsA("BasePart") or descendant:IsA("UnionOperation") then
        task.wait(0.5) -- Wait a bit for the part to be fully loaded
        task.spawn(function()
            addlight(descendant)
            synclight(descendant, 0.2, 35)
        end)
    end
end)
-- ===== END LIGHTING SYSTEM =====

-- Trail spawning loop - KEEP THIS WORKING!
while task.wait(0.1) do
    if not scriptActive then break end -- Only break if script is disabled
    
    spawn(function()
        -- Check if character still exists and has HRP
        if not char or not char.Parent or not char:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        local hrp = char.HumanoidRootPart
        local pos = hrp.CFrame * CFrame.new(0, -3.2, 0)
        local trail = serverendpoint:InvokeServer("CreatePart", "Normal", pos, char)

        setcollision(trail, false)
        syncmaterial(trail, Enum.Material.Granite)
        color(trail, Color3.new(0, 0, 0))
        resize(trail, Vector3.new(10, 0.5, 10), trail.CFrame)
        fire(trail)

        -- Add light to the trail too
        addlight(trail)
        synclight(trail, 5, 20)

        task.wait(1)
        delete(trail)
    end)
end

end)
BT("Canada Spam", function()
local player = game.Players.LocalPlayer
			local char = player.Character
			local tool
			for i,v in player:GetDescendants() do
				if v.Name == "SyncAPI" then
					tool = v.Parent
				end
			end
			for i,v in game.ReplicatedStorage:GetDescendants() do
				if v.Name == "SyncAPI" then
					tool = v.Parent
				end
			end
			--craaa
			remote = tool.SyncAPI.ServerEndpoint
			function _(args)
				remote:InvokeServer(unpack(args))
			end
			function SetCollision(part,boolean)
				local args = {
					[1] = "SyncCollision",
					[2] = {
						[1] = {
							["Part"] = part,
							["CanCollide"] = boolean
						}
					}
				}
				_(args)
			end
			function SetAnchor(boolean,part)
				local args = {
					[1] = "SyncAnchor",
					[2] = {
						[1] = {
							["Part"] = part,
							["Anchored"] = boolean
						}
					}
				}
				_(args)
			end
			function CreatePart(cf,parent)
				local args = {
					[1] = "CreatePart",
					[2] = "Normal",
					[3] = cf,
					[4] = parent
				}
				_(args)
			end
			function DestroyPart(part)
				local args = {
					[1] = "Remove",
					[2] = {
						[1] = part
					}
				}
				_(args)
			end
			function MovePart(part,cf)
				local args = {
					[1] = "SyncMove",
					[2] = {
						[1] = {
							["Part"] = part,
							["CFrame"] = cf
						}
					}
				}
				_(args)
			end
			function Resize(part,size,cf)
				local args = {
					[1] = "SyncResize",
					[2] = {
						[1] = {
							["Part"] = part,
							["CFrame"] = cf,
							["Size"] = size
						}
					}
				}
				_(args)
			end
			function AddMesh(part)
				local args = {
					[1] = "CreateMeshes",
					[2] = {
						[1] = {
							["Part"] = part
						}
					}
				}
				_(args)
			end
	
			function SetMesh(part,meshid)
				local args = {
					[1] = "SyncMesh",
					[2] = {
						[1] = {
							["Part"] = part,
							["MeshId"] = "rbxassetid://"..meshid
						}
					}
				}
				_(args)
			end
			function SetTexture(part, texid)
				local args = {
					[1] = "SyncMesh",
					[2] = {
						[1] = {
							["Part"] = part,
							["TextureId"] = "rbxassetid://"..texid
						}
					}
				}
				_(args)
			end
			function SetName(part, stringg)
				local args = {
					[1] = "SetName",
					[2] = {
						[1] = part
					},
					[3] = stringg
				}
	
				_(args)
			end
			function MeshResize(part,size)
				local args = {
					[1] = "SyncMesh",
					[2] = {
						[1] = {
							["Part"] = part,
							["Scale"] = size
						}
					}
				}
				_(args)
			end
			function Weld(part1, part2,lead)
				local args = {
					[1] = "CreateWelds",
					[2] = {
						[1] = part1,
						[2] = part2
					},
					[3] = lead
				}
				_(args)
	
			end
			function SetLocked(part,boolean)
				local args = {
					[1] = "SetLocked",
					[2] = {
						[1] = part
					},
					[3] = boolean
				}
				_(args)
			end
			function SetTrans(part,int)
				local args = {
					[1] = "SyncMaterial",
					[2] = {
						[1] = {
							["Part"] = part,
							["Transparency"] = int
						}
					}
				}
				_(args)
			end
			function CreateSpotlight(part)
				local args = {
					[1] = "CreateLights",
					[2] = {
						[1] = {
							["Part"] = part,
							["LightType"] = "SpotLight"
						}
					}
				}
				_(args)
			end
			function SyncLighting(part,brightness)
				local args = {
					[1] = "SyncLighting",
					[2] = {
						[1] = {
							["Part"] = part,
							["LightType"] = "SpotLight",
							["Brightness"] = brightness
						}
					}
				}
				_(args)
			end
			function Color(part,color)
				local args = {
					[1] = "SyncColor",
					[2] = {
						[1] = {
							["Part"] = part,
							["Color"] = color --[[Color3]],
							["UnionColoring"] = false
						}
					}
				}
				_(args)
			end
			function SpawnDecal(part,side)
				local args = {
					[1] = "CreateTextures",
					[2] = {
						[1] = {
							["Part"] = part,
							["Face"] = side,
							["TextureType"] = "Decal"
						}
					}
				}
	
				_(args)
			end
			function AddDecal(part,asset,side)
				local args = {
					[1] = "SyncTexture",
					[2] = {
						[1] = {
							["Part"] = part,
							["Face"] = side,
							["TextureType"] = "Decal",
							["Texture"] = "rbxassetid://".. asset
						}
					}
				}
				_(args)
			end
	
			function spam(id)
				for i,v in game.workspace:GetDescendants() do
					if v:IsA("BasePart") then
						spawn(function()
							SetLocked(v,false)
							SpawnDecal(v,Enum.NormalId.Front)
							AddDecal(v,id,Enum.NormalId.Front)
	
							SpawnDecal(v,Enum.NormalId.Back)
							AddDecal(v,id,Enum.NormalId.Back)
	
							SpawnDecal(v,Enum.NormalId.Right)
							AddDecal(v,id,Enum.NormalId.Right)
	
							SpawnDecal(v,Enum.NormalId.Left)
							AddDecal(v,id,Enum.NormalId.Left)
	
							SpawnDecal(v,Enum.NormalId.Bottom)
							AddDecal(v,id,Enum.NormalId.Bottom)
	
							SpawnDecal(v,Enum.NormalId.Top)
							AddDecal(v,id,Enum.NormalId.Top)
						end)
					end
				end 
			end
			spam("6924369153")
end)

BT("Obunga SkyBox", function()
RequestCommandSilent:InvokeServer(";fogcolor black ;time 0")
local player = game.Players.LocalPlayer

    local char = player.Character

    local tool

    for i,v in player:GetDescendants() do

        if v.Name == "SyncAPI" then

            tool = v.Parent

        end

    end

    for i,v in game.ReplicatedStorage:GetDescendants() do

        if v.Name == "SyncAPI" then

            tool = v.Parent

        end

    end

    --craaa

    remote = tool.SyncAPI.ServerEndpoint

    function _(args)

        remote:InvokeServer(unpack(args))

    end

    function SetCollision(part,boolean)

        local args = {

            [1] = "SyncCollision",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["CanCollide"] = boolean

                }

            }

        }

        _(args)

    end

    function SetAnchor(boolean,part)

        local args = {

            [1] = "SyncAnchor",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Anchored"] = boolean

                }

            }

        }

        _(args)

    end

    function CreatePart(cf,parent)

        local args = {

            [1] = "CreatePart",

            [2] = "Normal",

            [3] = cf,

            [4] = parent

        }

        _(args)

    end

    function DestroyPart(part)

        local args = {

            [1] = "Remove",

            [2] = {

                [1] = part

            }

        }

        _(args)

    end

    function MovePart(part,cf)

        local args = {

            [1] = "SyncMove",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["CFrame"] = cf

                }

            }

        }

        _(args)

    end

    function Resize(part,size,cf)

        local args = {

            [1] = "SyncResize",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["CFrame"] = cf,

                    ["Size"] = size

                }

            }

        }

       _(args)

    end

    function AddMesh(part)

        local args = {

            [1] = "CreateMeshes",

            [2] = {

                [1] = {

                    ["Part"] = part

                }

            }

        }

        _(args)

    end

    function SetMesh(part,meshid)

        local args = {

            [1] = "SyncMesh",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["MeshId"] = "rbxassetid://"..meshid

                }

            }

        }

        _(args)

    end

    function SetTexture(part, texid)

        local args = {

            [1] = "SyncMesh",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["TextureId"] = "rbxassetid://"..texid

                }

            }

        }

        _(args)

    end

    function SetName(part, stringg)

        local args = {

            [1] = "SetName",

            [2] = {

                [1] = part

            },

            [3] = stringg

        }

        _(args)

    end

    function MeshResize(part,size)

        local args = {

            [1] = "SyncMesh",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Scale"] = size

                }

            }

        }

        _(args)

    end

    function Weld(part1, part2,lead)

        local args = {

            [1] = "CreateWelds",

            [2] = {

                [1] = part1,

                [2] = part2

            },

            [3] = lead

        }

        _(args)

    end

    function SetLocked(part,boolean)

        local args = {

            [1] = "SetLocked",

            [2] = {

                [1] = part

            },

            [3] = boolean

        }

        _(args)

    end

    function SetTrans(part,int)

        local args = {

            [1] = "SyncMaterial",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Transparency"] = int

                }

            }

        }

        _(args)

    end

    function CreateSpotlight(part)

        local args = {

           [1] = "CreateLights",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["LightType"] = "SpotLight"

                }

            }

        }

        _(args)

    end

    function SyncLighting(part,brightness)

        local args = {

            [1] = "SyncLighting",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["LightType"] = "SpotLight",

                    ["Brightness"] = brightness

                }

            }

        }

        _(args)

    end

    function Color(part,color)

        local args = {

            [1] = "SyncColor",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Color"] = color --[[Color3]],

                    ["UnionColoring"] = false

                }

            }

        }

        _(args)

    end

    function SpawnDecal(part,side)

        local args = {

            [1] = "CreateTextures",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Face"] = side,

                    ["TextureType"] = "Decal"

                }

            }

        }

        _(args)

    end

    function AddDecal(part,asset,side)

        local args = {

            [1] = "SyncTexture",

            [2] = {

                [1] = {

                    ["Part"] = part,

                    ["Face"] = side,

                    ["TextureType"] = "Decal",

                    ["Texture"] = "rbxassetid://".. asset

                }

            }

        }

        _(args)

    end

    function Sky(id)

        e = char.HumanoidRootPart.CFrame.x

        f = char.HumanoidRootPart.CFrame.y

        g = char.HumanoidRootPart.CFrame.z

        CreatePart(CFrame.new(math.floor(e),math.floor(f),math.floor(g)) + Vector3.new(0,6,0),workspace)

        for i,v in game.Workspace:GetDescendants() do

            if v:IsA("BasePart") and v.CFrame.x == math.floor(e) and v.CFrame.z == math.floor(g) then

                --spawn(function()

                SetName(v,"Sky")

                AddMesh(v)

                --end)

                --spawn(function()

                SetMesh(v,"111891702759441")

                SetTexture(v,id)

                --end)

                MeshResize(v,Vector3.new(90000,90000,90000))

                SetLocked(v,true)

            end

        end

    end

    Sky("84527322179693")
end)
BT("Dancing Skeleton SkyBox", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";fogcolor black")
SilentRequest:InvokeServer(";time 0")
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for i, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for i, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint
local RunService = game:GetService("RunService")

function _(args)
    remote:InvokeServer(unpack(args))
end

function CreatePart(cf, parent)
    local args = {
        [1] = "CreatePart",
        [2] = "Normal",
        [3] = cf,
        [4] = parent
    }
    _(args)
end

function SetAnchor(part, boolean)
    local args = {
        [1] = "SyncAnchor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Anchored"] = boolean
            }
        }
    }
    _(args)
end

function AddMesh(part)
    local args = {
        [1] = "CreateMeshes",
        [2] = {
            [1] = {
                ["Part"] = part
            }
        }
    }
    _(args)
end

function SetMesh(part, meshid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["MeshId"] = "rbxassetid://" .. meshid
            }
        }
    }
    _(args)
end

function SetTexture(part, texid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["TextureId"] = texid
            }
        }
    }
    _(args)
end

function MeshResize(part, size)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Scale"] = size
            }
        }
    }
    _(args)
end

function SetTransparency(part, value)
    local args = {
        [1] = "SyncTransparency",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Transparency"] = value
            }
        }
    }
    _(args)
end

function DestroyPart(part)
    local args = {
        [1] = "Remove",
        [2] = {
            [1] = part
        }
    }
    _(args)
end

local images = {
    "http://www.roblox.com/asset/?id=169585459",
    "http://www.roblox.com/asset/?id=169585475",
    "http://www.roblox.com/asset/?id=169585485",
    "http://www.roblox.com/asset/?id=169585502",
    "http://www.roblox.com/asset/?id=169585515",
    "http://www.roblox.com/asset/?id=169585502",
    "http://www.roblox.com/asset/?id=169585485",
    "http://www.roblox.com/asset/?id=169585475"
}

local skyPart
local skyLoop
local frameTime = 1 / 10
local lastUpdate = 0

function CreateSky()
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local cf = hrp.CFrame
    CreatePart(CFrame.new(cf.Position + Vector3.new(0, 6, 0)), workspace)

    local found = false
    for i = 1, 50 do
        task.wait()
        for _, v in workspace:GetDescendants() do
            if v:IsA("BasePart") and (v.Position - (cf.Position + Vector3.new(0, 6, 0))).Magnitude < 1 then
                skyPart = v
                found = true
                break
            end
        end
        if found then break end
    end

    if not skyPart then return end

    SetAnchor(skyPart, true)
    AddMesh(skyPart)
    SetMesh(skyPart, "111891702759441")
    MeshResize(skyPart, Vector3.new(99999, 99999, 99999))
    SetTransparency(skyPart, 0)

    local index = 1
    skyLoop = RunService.Heartbeat:Connect(function(deltaTime)
        lastUpdate = lastUpdate + deltaTime
        if lastUpdate >= frameTime then
            lastUpdate = 0
            if not skyPart then
                skyLoop:Disconnect()
                return
            end
            SetTexture(skyPart, images[index])
            index = (index % #images) + 1
        end
    end)
end

function ResetSky()
    if skyLoop then
        skyLoop:Disconnect()
        skyLoop = nil
    end
    if skyPart then
        DestroyPart(skyPart)
        skyPart = nil
    end
    task.spawn(CreateSky)
end

player.CharacterAdded:Connect(function(newChar)
    char = newChar
    ResetSky()
end)

if char and char:FindFirstChild("Humanoid") then
    char:WaitForChild("Humanoid").Died:Connect(function()
        ResetSky()
    end)
end

CreateSky()
end)
BT("raining balls", function()
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

for _, v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end

local remote = tool.SyncAPI.ServerEndpoint

local function _(args)
    remote:InvokeServer(unpack(args))
end

function SetCollision(part, bool)
    _({"SyncCollision", {{Part = part, CanCollide = bool}}})
end

function SetAnchor(bool, part)
    _({"SyncAnchor", {{Part = part, Anchored = bool}}})
end

function CreatePart(cf)
    _({"CreatePart", "Ball", cf, workspace})
end

function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end

function SetName(part, name)
    _({"SetName", {part}, name})
end

function SetColor(part, color)
    _({"SyncMaterial", {{Part = part, Material = Enum.Material.Neon}}})
    _({"SyncColor", {{Part = part, Color = color}}})
end

local function randomColor3()
    return Color3.fromHSV(math.random(), 1, 1)
end

local root = player.Character:WaitForChild("HumanoidRootPart")

while task.wait(0.1) do
    local x = root.Position.X + math.random(-300, 300)
    local z = root.Position.Z + math.random(-300, 300)
    local y = root.Position.Y + math.random(150, 300)
    local cf = CFrame.new(math.floor(x), y, math.floor(z))

    spawn(function()
        CreatePart(cf)
        task.wait(0.05)
        
        for _, v in workspace:GetChildren() do
            if v:IsA("Part") and v.Name == "Part" and (v.Position - cf.Position).Magnitude < 2 then
                SetName(v, "FallingNeonBall")
                Resize(v, Vector3.new(40, 40, 40), v.CFrame)
                SetColor(v, randomColor3())
                SetCollision(v, true)
                SetAnchor(false, v)
                break
            end
        end
    end)
end

end)
BT("infinite yield", function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()

end)
BT("Old Meme Particles", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// SyncAPI Setup
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool

-- Try to find SyncAPI in player first
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
        break
    end
end
-- If not found, check ReplicatedStorage
if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
            break
        end
    end
end
if not tool then
    error("SyncAPI tool not found")
end

local remote = tool.SyncAPI.ServerEndpoint

--// Simple remote call wrapper
local function _(args)
    remote:InvokeServer(unpack(args))
end

--// Helper functions
local function CreatePart(cf, parent)
    _({"CreatePart", "Normal", cf, parent})
end
local function SetAnchor(part, state)
    _({"SyncAnchor", {{Part = part, Anchored = state}}})
end
local function SetCollision(part, state)
    _({"SyncCollision", {{Part = part, CanCollide = state}}})
end
local function AddMesh(part)
    _({"CreateMeshes", {{Part = part}}})
end
local function SetMesh(part, meshid)
    _({"SyncMesh", {{Part = part, MeshId = "rbxassetid://" .. meshid}}})
end
local function SetTexture(part, texid)
    _({"SyncMesh", {{Part = part, TextureId = "rbxassetid://" .. texid}}})
end
local function MeshResize(part, size)
    _({"SyncMesh", {{Part = part, Scale = size}}})
end
local function SetLocked(part, state)
    _({"SetLocked", {part}, state})
end
local function Resize(part, size, cf)
    _({"SyncResize", {{Part = part, CFrame = cf, Size = size}}})
end
local function SpawnDecal(part, face)
    _({"CreateTextures", {{Part = part, Face = face, TextureType = "Decal"}}})
end
local function AddDecal(part, asset, face)
    _({"SyncTexture", {{Part = part, Face = face, TextureType = "Decal", Texture = "rbxassetid://"..asset}}})
end
local function SetName(part, name)
    _({"SetName", {part}, name})
end
local function SetTrans(part, val)
    _({"SyncMaterial", {{Part = part, Transparency = val}}})
end
local function delete(part)
    _({"Remove", {part}})
end

--// === Improved Particle Effect System ===
local activeParticles = {}
local particleCooldowns = {}

local function createParticleForPlayer(targetPlayer, textureId, offsetY)
    -- Wait for character to load
    local character = targetPlayer.Character
    if not character then
        targetPlayer.CharacterAdded:Wait()
        character = targetPlayer.Character
    end
    
    local humanoid = character:WaitForChild("Humanoid")
    local playerKey = targetPlayer.UserId
    
    local cooldownKey = playerKey .. "_" .. textureId
    particleCooldowns[cooldownKey] = particleCooldowns[cooldownKey] or 0
    
    while true do
        local currentTime = tick()
        if currentTime - particleCooldowns[cooldownKey] >= 2 then
            particleCooldowns[cooldownKey] = currentTime
            
            if not targetPlayer or not targetPlayer.Parent or not character or not character.Parent or humanoid.Health <= 0 then
                break
            end
            
            local head = character:FindFirstChild("Head")
            if not head then
                task.wait(1)
                continue
            end

            -- Spawn particle above head with texture-specific Y offset
            local spawnCFrame = head.CFrame + Vector3.new(0, 3 + offsetY, 0)
            
            task.spawn(function()  
                CreatePart(spawnCFrame, workspace)  
                task.wait(0.1)  

                -- Grab the newly created part
                local newPart = nil
                for _, v in workspace:GetChildren() do  
                    if v:IsA("Part") and (v.Position - spawnCFrame.Position).Magnitude < 1 then  
                        newPart = v
                        break
                    end  
                end
                
                if newPart then
                    SetName(newPart, "particle_" .. targetPlayer.Name .. "_" .. textureId)  
                    Resize(newPart, Vector3.new(6, 6, 0.001), newPart.CFrame)  
                    SetCollision(newPart, false)  
                    SetTrans(newPart, 1)  
                    SetAnchor(newPart, true)  
                    newPart.Orientation = Vector3.new(0, 0, 0)  

                    SpawnDecal(newPart, Enum.NormalId.Front)  
                    AddDecal(newPart, textureId, Enum.NormalId.Front)  
                    SpawnDecal(newPart, Enum.NormalId.Back)  
                    AddDecal(newPart, textureId, Enum.NormalId.Back)  

                    -- Track this particle
                    local particleId = #activeParticles + 1
                    activeParticles[particleId] = newPart

                    -- Animate particle rising
                    for i = 1, 40 do
                        if newPart and newPart.Parent and head and head.Parent then  
                            local currentHeadPos = head.Position
                            local newPosition = Vector3.new(
                                currentHeadPos.X,
                                spawnCFrame.Position.Y + (i * 2),
                                currentHeadPos.Z
                            )
                            Resize(newPart, newPart.Size, CFrame.new(newPosition))
                            task.wait(0.05)
                        else
                            break
                        end
                    end  

                    if newPart and newPart.Parent then
                        delete(newPart)  
                    end
                    activeParticles[particleId] = nil
                end  
            end)
        end
        task.wait(0.5)
    end
end

--// === Manage Particles for All Players ===
local function startParticleSystem()
    local textureIds = {
        "12667521510",
        "12585611688",
        "76658875202103"
    }

    local activeConnections = {}
    
    local function startForPlayer(player)
        for i, texId in ipairs(textureIds) do
            local yOffset = (i-1) * 2  -- stack textures above each other
            coroutine.wrap(function()
                createParticleForPlayer(player, texId, yOffset)
            end)()
        end
    end
    
    local function stopForPlayer(player)
        for particleId, part in pairs(activeParticles) do
            if part.Name:find(player.Name) and part.Parent then
                delete(part)
                activeParticles[particleId] = nil
            end
        end
    end
    
    for _, existingPlayer in ipairs(Players:GetPlayers()) do
        startForPlayer(existingPlayer)
    end
    
    Players.PlayerAdded:Connect(function(newPlayer)
        startForPlayer(newPlayer)
    end)
    
    Players.PlayerRemoving:Connect(function(leavingPlayer)
        stopForPlayer(leavingPlayer)
    end)
end

--// === Cleanup System ===
local function setupCleanup()
    while true do
        task.wait(10)
        for particleId, part in pairs(activeParticles) do
            if not part or not part.Parent then
                activeParticles[particleId] = nil
            end
        end
    end
end

--// === Run Particle System ===
startParticleSystem()
coroutine.wrap(setupCleanup)()
end)
BT("k00pkidd statue", function()
local player = game.Players.LocalPlayer
local char = player.Character
local tool
for i,v in player:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
for i,v in game.ReplicatedStorage:GetDescendants() do
    if v.Name == "SyncAPI" then
        tool = v.Parent
    end
end
--craaa
remote = tool.SyncAPI.ServerEndpoint
function _(args)
    remote:InvokeServer(unpack(args))
end
function SetCollision(part,boolean)
    local args = {
        [1] = "SyncCollision",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CanCollide"] = boolean
            }
        }
    }
    _(args)
end
function SetAnchor(boolean,part)
    local args = {
        [1] = "SyncAnchor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Anchored"] = boolean
            }
        }
    }
    _(args)
end
function CreatePart(cf,parent)
    local args = {
        [1] = "CreatePart",
        [2] = "Normal",
        [3] = cf,
        [4] = parent
    }
    _(args)
end
function MovePart(part,cf)
    local args = {
        [1] = "SyncMove",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CFrame"] = cf
            }
        }
    }
    _(args)
end
function Resize(part,size,cf)
    local args = {
        [1] = "SyncResize",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["CFrame"] = cf,
                ["Size"] = size
            }
        }
    }
    _(args)
end
function AddMesh(part)
    local args = {
        [1] = "CreateMeshes",
        [2] = {
            [1] = {
                ["Part"] = part
            }
        }
    }
    _(args)
end

function SetMesh(part,meshid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["MeshId"] = "rbxassetid://"..meshid
            }
        }
    }
    _(args)
end
function SetTexture(part, texid)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["TextureId"] = "rbxassetid://"..texid
            }
        }
    }
    _(args)
end
function SetName(part, stringg)
    local args = {
        [1] = "SetName",
        [2] = {
            [1] = part
        },
        [3] = stringg
    }
    _(args)
end
function MeshResize(part,size)
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Scale"] = size
            }
        }
    }
    _(args)
end
function Weld(part1, part2,lead)
    local args = {
        [1] = "CreateWelds",
        [2] = {
            [1] = part1,
            [2] = part2
        },
        [3] = lead
    }
    _(args)
end
function SetLocked(part,boolean)
    local args = {
        [1] = "SetLocked",
        [2] = {
            [1] = part
        },
        [3] = boolean
    }
    _(args)
end
function SetTrans(part,int)
    local args = {
        [1] = "SyncMaterial",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Transparency"] = int
            }
        }
    }
    _(args)
end
function CreateSpotlight(part)
    local args = {
        [1] = "CreateLights",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["LightType"] = "SpotLight"
            }
        }
    }
    _(args)
end
function SyncLighting(part,brightness)
    local args = {
        [1] = "SyncLighting",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["LightType"] = "SpotLight",
                ["Brightness"] = brightness
            }
        }
    }
    _(args)
end
function Color(part,color)
    local args = {
        [1] = "SyncColor",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Color"] = color --[[Color3]],
                ["UnionColoring"] = false
            }
        }
    }
    _(args)
end
function SpawnDecal(part,side)
    local args = {
        [1] = "CreateTextures",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Face"] = side,
                ["TextureType"] = "Decal"
            }
        }
    }
    _(args)
end
function AddDecal(part,asset,side)
    local args = {
        [1] = "SyncTexture",
        [2] = {
            [1] = {
                ["Part"] = part,
                ["Face"] = side,
                ["TextureType"] = "Decal",
                ["Texture"] = "rbxassetid://".. asset
            }
        }
    }
    _(args)
end

function Krab(id)
    e = char.HumanoidRootPart.CFrame.x
    f = char.HumanoidRootPart.CFrame.y
    g = char.HumanoidRootPart.CFrame.z
    CreatePart(CFrame.new(math.floor(e),math.floor(f),math.floor(g)) + Vector3.new(0,7,0),workspace)
    for i,v in game.Workspace:GetDescendants() do
        if v:IsA("BasePart") and v.CFrame.x == math.floor(e) and v.CFrame.z == math.floor(g) then
            SetName(v,"Blue2spookys Krusty Krab")
            AddMesh(v)
            SetMesh(v,"1347582902")
            SetTexture(v,id)
            MeshResize(v,Vector3.new(0.1,0.1,0.1))
            SetLocked(v,true)

            local basePosition = v.Position
            local pos4 = CFrame.new(basePosition) * CFrame.new(0, 5, 0)
            CreatePart(pos4, workspace)

            for i,newPart in game.Workspace:GetDescendants() do
                if newPart:IsA("BasePart") and newPart ~= v and newPart.CFrame.x == pos4.x and newPart.CFrame.z == pos4.z then
                    SetName(newPart, "Krab Head Mesh")
                    AddMesh(newPart)
                    SetMesh(newPart, "5924046624")
                    SetTexture(newPart, "5924037225")
                    MeshResize(newPart, Vector3.new(3, 3, 3)) -- <<< Increased head size
                    SetLocked(newPart, true)
                    MovePart(newPart, newPart.CFrame * CFrame.new(0, 6.25, 0))
                    break
                end
            end
        end
    end
end

Krab("125929634799364")

end)
BT("Random Colors", function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local backpack = player:WaitForChild("Backpack")

-- ===============================
-- FIND F3X (SyncAPI)
-- ===============================
local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	for _, v in ipairs(player.Character:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	return nil
end

local f3x = getf3x()
if not f3x then
	warn("âŒ You don't have F3X equipped.")
	return
end

local syncapi = f3x:WaitForChild("SyncAPI")
local serverendpoint = syncapi:WaitForChild("ServerEndpoint")

-- ===============================
-- FAST INVOKE FUNCTION
-- ===============================
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

local function setColor(part, color)
	fastInvoke({
		"SyncColor",
		{
			{
				["Part"] = part,
				["Color"] = color,
				["UnionColoring"] = false
			}
		}
	})
end

-- ===============================
-- RANDOM COLOR FUNCTION
-- ===============================
local function randomColor()
	return Color3.fromRGB(
		math.random(0, 255),
		math.random(0, 255),
		math.random(0, 255)
	)
end

-- ===============================
-- CHANGE COLORS OF ALL PARTS
-- ===============================
local parts = workspace:GetDescendants()
local total = 0

for _, v in ipairs(parts) do
	if v:IsA("BasePart") or v:IsA("UnionOperation") then
		total += 1
		setColor(v, randomColor())
	end
end

print("âœ… Changed color of " .. total .. " parts randomly once!")

end)
BT("Make Everything Meshes", function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local backpack = player:WaitForChild("Backpack")

-- ===============================
-- FIND F3X (SyncAPI)
-- ===============================
local function getf3x()
	for _, v in ipairs(backpack:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	for _, v in ipairs(player.Character:GetChildren()) do
		if v:FindFirstChild("SyncAPI") then
			return v
		end
	end
	return nil
end

local f3x = getf3x()
if not f3x then
	warn("âŒ You don't have F3X equipped.")
	return
end

local syncapi = f3x:WaitForChild("SyncAPI")
local serverendpoint = syncapi:WaitForChild("ServerEndpoint")

-- ===============================
-- FAST INVOKE
-- ===============================
local function fastInvoke(args)
	task.spawn(function()
		pcall(function()
			serverendpoint:InvokeServer(unpack(args))
		end)
	end)
end

-- ===============================
-- MESH + SHAPE HELPERS
-- ===============================
local meshIds = {
	"rbxassetid://9756362",    -- cone
	"rbxassetid://20329976",   -- sphere-like
	"rbxassetid://19251107",   -- cylinder
	"rbxassetid://10470609",   -- wedge
	"rbxassetid://10470606",   -- head
	"rbxassetid://1095708",    -- pyramid
	"rbxassetid://9753878"     -- random rock
}

local shapes = {
	Enum.PartType.Block,
	Enum.PartType.Ball,
	Enum.PartType.Cylinder,
	Enum.PartType.Wedge,
	Enum.PartType.CornerWedge
}

local function randomMeshId()
	return meshIds[math.random(1, #meshIds)]
end

local function randomShape()
	return shapes[math.random(1, #shapes)]
end

-- ===============================
-- CONVERT PART FUNCTION
-- ===============================
local function convertPart(part)
	task.spawn(function()
		pcall(function()
			-- 50% chance to use built-in shape, 50% chance to give a mesh
			if math.random() < 0.5 then
				-- Basic shape change (Block, Ball, Cylinder, etc.)
				fastInvoke({
					"SyncShape",
					{
						{
							["Part"] = part,
							["Shape"] = randomShape()
						}
					}
				})
			else
				-- Give a random mesh
				fastInvoke({"CreateMeshes", {{["Part"] = part}}})
				fastInvoke({
					"SyncMesh",
					{
						{
							["Part"] = part,
							["MeshId"] = randomMeshId(),
							["Scale"] = Vector3.new(
								math.random(50, 200) / 100,
								math.random(50, 200) / 100,
								math.random(50, 200) / 100
							)
						}
					}
				})
			end
		end)
	end)
end

-- ===============================
-- APPLY TO EVERY PART
-- ===============================
local parts = workspace:GetDescendants()
local total = 0

for _, v in ipairs(parts) do
	if v:IsA("BasePart") or v:IsA("UnionOperation") then
		total += 1
		convertPart(v)
	end
end

print("âœ… Converted " .. total .. " parts into random shapes/meshes!")

end)
BT("Spin all", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";spin all 20")
end)
BT("Avatars", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";char all k00pkiddalt")
end)

BT("Brooklyn blood pop song", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 133251269532695")
SilentRequest:InvokeServer(";pitch 0.143")
SilentRequest:InvokeServer(";volume inf")

end)
BT("Real g00by theme!!", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local SilentRequest = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
        SilentRequest:InvokeServer(";music 1847661821")
SilentRequest:InvokeServer(";volume inf")

end)
BT("coffee shop", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()

-- ===============================
-- HDAdmin RequestCommand (global)
-- ===============================
local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
pcall(function()
RequestCommand:InvokeServer(";punish all")
end)

-- ===============================
-- F3X (SyncAPI) detection
-- ===============================
local backpack = player.Backpack
local function getf3x()
for _, v in ipairs(backpack:GetChildren()) do
if v:FindFirstChild("SyncAPI") then return v end
end
for _, v in ipairs(char:GetChildren()) do
if v:FindFirstChild("SyncAPI") then return v end
end
return nil
end

local f3x = getf3x()
if not f3x then
warn("You don't have F3X")
return
end
local syncapi = f3x.SyncAPI
local serverendpoint = syncapi.ServerEndpoint

-- Fast parallel invoke
local function fastInvoke(args)
task.spawn(function()
pcall(function()
serverendpoint:InvokeServer(unpack(args))
end)
end)
end

-- Delete part helper
local function delete(part)
fastInvoke({"Remove",{part}})
end

-- ===============================
-- FAST DELETE EVERYTHING
-- ===============================
for _, v in ipairs(workspace:GetDescendants()) do
if v:IsA("BasePart") or v:IsA("UnionOperation") then
task.spawn(function()
pcall(function() delete(v) end)
end)
end
end

print("All parts deleted (fast).")
task.wait(0.8)

-- ===============================
-- FAST BUILDING FUNCTIONS
-- ===============================

local function createPart(partType, cf, size, material, col, nameStr, anchored, collide, extra)
task.spawn(function()
local part = serverendpoint:InvokeServer("CreatePart", partType, cf, workspace)
if part then
-- Apply all properties in parallel
fastInvoke({"SyncResize",{{["Part"]=part,["CFrame"]=cf,["Size"]=size}}})
fastInvoke({"SyncMaterial",{{["Part"]=part,["Material"]=material}}})
fastInvoke({"SyncColor",{{["Part"]=part,["Color"]=col,["UnionColoring"]=false}}})
fastInvoke({"SetName",{part}, nameStr})
fastInvoke({"SetLocked",{part}, true})
fastInvoke({"SyncAnchor",{{["Part"]=part,["Anchored"]=anchored}}})
fastInvoke({"SyncCollision",{{["Part"]=part,["CanCollide"]=collide}}})
if extra then extra(part) end
end
end)
end

local function resize(part, size, cf)
fastInvoke({"SyncResize",{{["Part"]=part,["CFrame"]=cf,["Size"]=size}}})
end

local function mat(part, mate)
fastInvoke({"SyncMaterial",{{["Part"]=part,["Material"]=mate}}})
end

local function color(part, col)
fastInvoke({"SyncColor",{{["Part"]=part,["Color"]=col,["UnionColoring"]=false}}})
end

local function transparency(part, trans)
fastInvoke({"SyncMaterial",{{["Part"]=part,["Transparency"]=trans}}})
end

local function setcollision(part, bool)
fastInvoke({"SyncCollision",{{["Part"]=part,["CanCollide"]=bool}}})
end

local function setanchor(part, bool)
fastInvoke({"SyncAnchor",{{["Part"]=part,["Anchored"]=bool}}})
end

local function createtexture(part, side)
fastInvoke({"CreateTextures",{{["Part"]=part,["Face"]=side,["TextureType"]="Texture"}}})
end

local function createdecal(part, side)
fastInvoke({"CreateTextures",{{["Part"]=part,["Face"]=side,["TextureType"]="Decal"}}})
end

local function setdecal(part, asset, side)
fastInvoke({"SyncTexture",{{["Part"]=part,["Face"]=side,["TextureType"]="Decal",["Texture"]="rbxassetid://"..asset}}})
end

local function makemesh(part)
fastInvoke({"CreateMeshes",{{["Part"]=part}}})
end

local function syncmeshid(part, id)
fastInvoke({"SyncMesh",{{["Part"]=part,["MeshId"]="rbxassetid://"..id}}})
end

local function syncmeshsize(part, vectora)
fastInvoke({"SyncMesh",{{["Part"]=part,["Scale"]=vectora}}})
end

local function syncmeshtexture(part, id)
fastInvoke({"SyncMesh",{{["Part"]=part,["TextureId"]="rbxassetid://"..id}}})
end

function MovePart(part, cf)
fastInvoke({"SyncMove",{{["Part"]=part,["CFrame"]=cf}}})
end

function floor(part, face)  
	fastInvoke({  
		[1] = "SyncTexture",  
		[2] = {  
			[1] = {  
				["Part"] = part,  
				["Face"] = face,  
				["TextureType"] = "Texture",  
				["Texture"] = "rbxassetid://135172958780980",  
				["StudsPerTileV"] = 2,  
				["StudsPerTileU"] = 2  
			}  
		}  
	})  
end  

function getwooded(part, face)  
	fastInvoke({  
		[1] = "SyncTexture",  
		[2] = {  
			[1] = {  
				["Part"] = part,  
				["Face"] = face,  
				["TextureType"] = "Texture",  
				["Texture"] = "rbxassetid://94153618",  
				["StudsPerTileV"] = 10,  
				["StudsPerTileU"] = 10  
			}  
		}  
	})  
end

function getFlooredLMFAO(part, face)
fastInvoke({
[1] = "SyncTexture",
[2] = {
[1] = {
["Part"] = part,
["Face"] = face,
["TextureType"] = "Texture",
["Texture"] = "rbxassetid://55420352",
["StudsPerTileV"] = 10,
["StudsPerTileU"] = 10
}
}
})
end

local function light(part)
fastInvoke({"CreateLights",{{["Part"]=part,["LightType"]="PointLight"}}})
fastInvoke({"SyncLighting",{{["Part"]=part,["LightType"]="PointLight",["Color"]=Color3.fromRGB(255,255,255),["Range"]=50}}})
end

-- ===============================
-- FAST REALM CONSTRUCTION
-- ===============================
local function RealmV2()
-- Create all parts in parallel
local parts = {
-- Floor
{CFrame.new(-47.979, 0, -26.237), Vector3.new(63, 1, 66), Enum.Material.SmoothPlastic, Color3.fromRGB(230, 230, 230), "Floor", function(p) 
	createtexture(p, Enum.NormalId.Top)
	getFlooredLMFAO(p, Enum.NormalId.Top)
end},

-- Walls and structures
{CFrame.new(-67.979, 2.25, -34.687), Vector3.new(23, 5.5, 1.1), Enum.Material.WoodPlanks, Color3.fromRGB(10, 10, 10), "Wall1"},
{CFrame.new(-67.979, 9, -34.737), Vector3.new(23, 19, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall2"},
{CFrame.new(-67.979, 9, -46.437), Vector3.new(23, 19, 24.4), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall3"},
{CFrame.new(-47.979, 9, -58.737), Vector3.new(63, 19, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall4", function(p)
	createtexture(p, Enum.NormalId.Back)
	getwooded(p, Enum.NormalId.Back)
end},
{CFrame.new(-15.979, 9, -26.237), Vector3.new(1, 19, 66), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall5", function(p)
	createtexture(p, Enum.NormalId.Left)
	getwooded(p, Enum.NormalId.Left)
end},
{CFrame.new(-79.979, 9, -26.237), Vector3.new(1, 19, 66), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall6", function(p)
	createtexture(p, Enum.NormalId.Right)
	getwooded(p, Enum.NormalId.Right)
end},
{CFrame.new(-20.979, 15, 6.263), Vector3.new(11, 7, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall7"},
{CFrame.new(-25.479, 9, 6.263), Vector3.new(2, 19, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall8"},
{CFrame.new(-52.479, 1.5, 6.263), Vector3.new(56, 4, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall9", function(p)
	createtexture(p, Enum.NormalId.Front)
	getwooded(p, Enum.NormalId.Front)
end},
{CFrame.new(-49.979, 8.5, 6.613), Vector3.new(47, 10, 0.1), Enum.Material.Glass, Color3.fromRGB(52, 216, 235), "GlassWall", function(p)
	transparency(p, 0.7)
end},
{CFrame.new(-76.479, 9, 6.263), Vector3.new(6, 19, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall10"},
{CFrame.new(-47.979, 19, -26.237), Vector3.new(63, 1, 66), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Ceiling", function(p)
	light(p)
end},
{CFrame.new(-20.479, 6.05, 6.263), Vector3.new(8, 10.9, 1), Enum.Material.Glass, Color3.fromRGB(52, 216, 235), "GlassWall2", function(p)
	transparency(p, 0.7)
	setcollision(p, false)
end},

-- Additional structural elements
{CFrame.new(-25.28, 1.4, -34.805), Vector3.new(15.7, 4.2, 2), Enum.Material.SmoothPlastic, Color3.fromRGB(0, 0, 0), "Struct1"},
{CFrame.new(-49.78, 1.75, -34.805), Vector3.new(13.5, 3.5, 2), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Struct2"},
{CFrame.new(-38.13, 3.1, -35.755), Vector3.new(10, 6.2, 0.1), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Struct3"},
{CFrame.new(-38.13, 5.15, -34.805), Vector3.new(10, 0.3, 2), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Struct4"},
{CFrame.new(-38.13, 3.15, -34.805), Vector3.new(10, 0.3, 2), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Struct5"},
{CFrame.new(-38.13, 0.75, -34.805), Vector3.new(10, 1.5, 2), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Struct6"},

-- More walls and details
{CFrame.new(-49.479, 9, 6.263), Vector3.new(10, 19, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall11", function(p)
	createtexture(p, Enum.NormalId.Front)
	getwooded(p, Enum.NormalId.Front)
end},
{CFrame.new(-51.479, 8, 6.263), Vector3.new(50, 1, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall12", function(p)
	createtexture(p, Enum.NormalId.Front)
	getwooded(p, Enum.NormalId.Front)
end},
{CFrame.new(-62.979, 9, 6.263), Vector3.new(1, 19, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall13", function(p)
	createtexture(p, Enum.NormalId.Front)
	getwooded(p, Enum.NormalId.Front)
end},
{CFrame.new(-49.979, 16, 6.263), Vector3.new(51, 5, 1), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "Wall14", function(p)
	createtexture(p, Enum.NormalId.Front)
	getwooded(p, Enum.NormalId.Front)
end},
{CFrame.new(-53.479, 13.5, 10.129), Vector3.new(54, 1, 9), Enum.Material.SmoothPlastic, Color3.fromRGB(5, 5, 5), "Platform"},

-- Angled elements
{CFrame.new(-76.429, 16.393, 8.886), Vector3.new(0.1, 7.4, 0.1), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Angled1", function(p)
	MovePart(p, p.CFrame * CFrame.Angles(math.rad(-44.998), 0, 0))
end},
{CFrame.new(-57.329, 16.393, 8.886), Vector3.new(0.1, 7.4, 0.1), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Angled2", function(p)
	MovePart(p, p.CFrame * CFrame.Angles(math.rad(-44.998), 0, 0))
end},
{CFrame.new(-37.829, 16.393, 8.886), Vector3.new(0.1, 7.4, 0.1), Enum.Material.SmoothPlastic, Color3.new(1, 1, 1), "Angled3", function(p)
	MovePart(p, p.CFrame * CFrame.Angles(math.rad(-44.998), 0, 0))
end},

-- Door frames
{CFrame.new(-25.479, 11, 7.763), Vector3.new(2, 23, 4), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "DoorFrame1"},
{CFrame.new(-16.479, 11, 7.763), Vector3.new(2, 23, 4), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "DoorFrame2"},
{CFrame.new(-20.979, 17, 7.763), Vector3.new(11, 11, 4), Enum.Material.SmoothPlastic, Color3.fromRGB(46, 46, 46), "DoorFrameTop"},

-- Foundation
{CFrame.new(-50.369, -0.436, -27.163), Vector3.new(84.7, 0.8, 95.4), Enum.Material.Concrete, Color3.fromRGB(100, 100, 100), "Foundation1"},
{CFrame.new(-41.816, -0.836, -9.237), Vector3.new(504, 1, 474), Enum.Material.SmoothPlastic, Color3.fromRGB(200, 200, 200), "Foundation2", function(p)
	createtexture(p, Enum.NormalId.Top)
	floor(p, Enum.NormalId.Top)
end}
}

-- Create all basic parts in parallel
for _, partData in ipairs(parts) do
createPart("Normal", partData[1], partData[2], partData[3], partData[4], partData[5], true, true, partData[6])
end

-- Create special parts (doors, decorations, etc.)
task.wait(0.5)

-- Doors
local doorPositions = {
CFrame.new(-30.818, 2.5, 0.635),
CFrame.new(-45.818, 2.5, 0.635),
CFrame.new(-61.818, 2.5, 0.635)
}

for _, pos in ipairs(doorPositions) do
task.spawn(function()
local door = serverendpoint:InvokeServer("CreatePart", "Normal", pos, workspace)
if door then
makemesh(door)
syncmeshid(door, "108885615243219")
color(door, Color3.fromRGB(10, 10, 10))
MovePart(door, door.CFrame * CFrame.Angles(0, math.rad(90), 0))
fastInvoke({"SetName",{door}, "Door"})
fastInvoke({"SetLocked",{door}, true})
fastInvoke({"SyncAnchor",{{["Part"]=door,["Anchored"]=true}}})
end
end)
end

-- Krusty Krab statue
task.spawn(function()
local Koohat = CFrame.new(-27.064, 10.6, -37.637)
local hat1 = serverendpoint:InvokeServer("CreatePart", "Normal", Koohat, workspace)
if hat1 then
makemesh(hat1)
syncmeshid(hat1, "5924046624")
syncmeshtexture(hat1, "5924037225")
syncmeshsize(hat1, Vector3.new(1.5, 1.5, 1.5))
fastInvoke({"SetLocked",{hat1}, true})
fastInvoke({"SyncAnchor",{{["Part"]=hat1,["Anchored"]=true}}})
end
end)

task.spawn(function()
local koopPos = CFrame.new(-26.896, 5, -37.605)
local K00pkid = serverendpoint:InvokeServer("CreatePart", "Normal", koopPos, workspace)
if K00pkid then
resize(K00pkid, Vector3.new(8, 10, 2), koopPos)
makemesh(K00pkid)
syncmeshid(K00pkid, "7879233630")
syncmeshtexture(K00pkid, "125929634799364")
syncmeshsize(K00pkid, Vector3.new(2, 2, 2))
MovePart(K00pkid, K00pkid.CFrame * CFrame.Angles(0, math.rad(-179.997), 0))
fastInvoke({"SetLocked",{K00pkid}, true})
fastInvoke({"SyncAnchor",{{["Part"]=K00pkid,["Anchored"]=true}}})
end
end)

-- Decals and signs
task.spawn(function()
local pos7 = CFrame.new(-0.703, 6.164, 7.43)
local text2 = serverendpoint:InvokeServer("CreatePart", "Normal", pos7, workspace)
if text2 then
setcollision(text2, false)
resize(text2, Vector3.new(29, 14, 1), pos7)
transparency(text2, 1)
createdecal(text2, Enum.NormalId.Back)
setdecal(text2, "83540930154917", Enum.NormalId.Back)
end
end)

task.spawn(function()
local pos7 = CFrame.new(-43.816, -0.836, 54.263)
local text2 = serverendpoint:InvokeServer("CreatePart", "Spawn", pos7, workspace)
if text2 then
setcollision(text2, false)
resize(text2, Vector3.new(1, 1, 1), pos7)
transparency(text2, 1)
end
end)

-- Additional decorations
task.spawn(function()
local Koohat = CFrame.new(-21.579, 4.744, -35.271)
local hat1 = serverendpoint:InvokeServer("CreatePart", "Normal", Koohat, workspace)
if hat1 then
makemesh(hat1)
syncmeshid(hat1, "10970208924")
syncmeshsize(hat1, Vector3.new(0.005, 0.005, 0.005))
syncmeshtexture(hat1, "10970209066")
fastInvoke({"SetLocked",{hat1}, true})
fastInvoke({"SyncAnchor",{{["Part"]=hat1,["Anchored"]=true}}})
end
end)

task.spawn(function()
local position = CFrame.new(-26.944, 13.05, -37.165)
local base = serverendpoint:InvokeServer("CreatePart", "Normal", position, workspace)
if base then
resize(base, Vector3.new(16.5, 14.1, 0.1), position)
transparency(base, 1)
setcollision(base, false)
createdecal(base, Enum.NormalId.Back)
setdecal(base, "88544851923301", Enum.NormalId.Back)
end
end)

task.spawn(function()
local Koohat = CFrame.new(-27.063, 8.828, -37.605)
local hat1 = serverendpoint:InvokeServer("CreatePart", "Normal", Koohat, workspace)
if hat1 then
makemesh(hat1)
syncmeshid(hat1, "5560742556")
syncmeshsize(hat1, Vector3.new(2, 2, 2))
color(hat1, Color3.fromRGB(35, 177, 77))
MovePart(hat1, hat1.CFrame * CFrame.Angles(0, math.rad(180), 0))
createdecal(hat1, Enum.NormalId.Back)
setdecal(hat1, "25321744", Enum.NormalId.Back)
fastInvoke({"SetLocked",{hat1}, true})
fastInvoke({"SyncAnchor",{{["Part"]=hat1,["Anchored"]=true}}})
end
end)

end

-- ===============================
-- MAIN EXECUTION
-- ===============================
local function realm()
RealmV2()

-- Load additional script
task.wait(2)

local player = game.Players.LocalPlayer
    local char = player.Character
    local tool
    for i,v in player:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
        end
    end
    for i,v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then
            tool = v.Parent
        end
    end
    --craaa
    remote = tool.SyncAPI.ServerEndpoint
    function _(args)
        remote:InvokeServer(unpack(args))
    end
    function SetCollision(part,boolean)
        local args = {
            [1] = "SyncCollision",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["CanCollide"] = boolean
                }
            }
        }
        _(args)
    end
    function SetAnchor(boolean,part)
        local args = {
            [1] = "SyncAnchor",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Anchored"] = boolean
                }
            }
        }
        _(args)
    end
    function CreatePart(cf,parent)
        local args = {
            [1] = "CreatePart",
            [2] = "Normal",
            [3] = cf,
            [4] = parent
        }
        _(args)
    end
    function DestroyPart(part)
        local args = {
            [1] = "Remove",
            [2] = {
                [1] = part
            }
        }
        _(args)
    end
    function MovePart(part,cf)
        local args = {
            [1] = "SyncMove",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["CFrame"] = cf
                }
            }
        }
        _(args)
    end
    function Resize(part,size,cf)
        local args = {
            [1] = "SyncResize",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["CFrame"] = cf,
                    ["Size"] = size
                }
            }
        }
        _(args)
    end
    function AddMesh(part)
        local args = {
            [1] = "CreateMeshes",
            [2] = {
                [1] = {
                    ["Part"] = part
                }
            }
        }
        _(args)
    end

    function SetMesh(part,meshid)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["MeshId"] = "rbxassetid://"..meshid
                }
            }
        }
        _(args)
    end
    function SetTexture(part, texid)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["TextureId"] = "rbxassetid://"..texid
                }
            }
        }
        _(args)
    end
    function SetName(part, stringg)
        local args = {
            [1] = "SetName",
            [2] = {
                [1] = part
            },
            [3] = stringg
        }

        _(args)
    end
    function MeshResize(part,size)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Scale"] = size
                }
            }
        }
        _(args)
    end
function MeshColor(part,color)
        local args = {
            [1] = "SyncMesh",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Color"] = color
                }
            }
        }
        _(args)
    end
    function Weld(part1, part2,lead)
        local args = {
            [1] = "CreateWelds",
            [2] = {
                [1] = part1,
                [2] = part2
            },
            [3] = lead
        }
        _(args)

    end
    function SetLocked(part,boolean)
        local args = {
            [1] = "SetLocked",
            [2] = {
                [1] = part
            },
            [3] = boolean
        }
        _(args)
    end

    function SetTrans(part,int)
        local args = {
            [1] = "SyncMaterial",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Transparency"] = int
                }
            }
        }
        _(args)
    end
    function CreateSpotlight(part)
        local args = {
            [1] = "CreateLights",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["LightType"] = "SpotLight"
                }
            }
        }
        _(args)
    end
    function SyncLighting(part,brightness)
        local args = {
            [1] = "SyncLighting",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["LightType"] = "SpotLight",
                    ["Brightness"] = brightness
                }
            }
        }
        _(args)
    end
    function Color(part,color)
        local args = {
            [1] = "SyncColor",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Color"] = color --[[Color3]],
                    ["UnionColoring"] = false
                }
            }
        }
        _(args)
    end
    function SpawnDecal(part,side)
        local args = {
            [1] = "CreateTextures",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Face"] = side,
                    ["TextureType"] = "Decal"
                }
            }
        }

        _(args)
    end
    function AddDecal(part,asset,side)
        local args = {
            [1] = "SyncTexture",
            [2] = {
                [1] = {
                    ["Part"] = part,
                    ["Face"] = side,
                    ["TextureType"] = "Decal",
                    ["Texture"] = "rbxassetid://".. asset
                }
            }
        }
        _(args)
    end

    function Sky(id)
        e = char.HumanoidRootPart.CFrame.x
        f = char.HumanoidRootPart.CFrame.y
        g = char.HumanoidRootPart.CFrame.z
        CreatePart(CFrame.new(math.floor(e),math.floor(f),math.floor(g)) + Vector3.new(0,6,0),workspace)
        for i,v in game.Workspace:GetDescendants() do
            if v:IsA("BasePart") and v.CFrame.x == math.floor(e) and v.CFrame.z == math.floor(g) then
                --spawn(function()
                SetName(v,"Sky")
                AddMesh(v)
                --end)
                --spawn(function()
                SetMesh(v,"111891702759441")
                SetTexture(v,id)
                --end)
                MeshResize(v,Vector3.new(99999,99999,99999))
                SetLocked(v,true)
            end
        end
    end
    Sky("9820931824")

end

realm()

-- Final HDAdmin commands
task.wait(3)
pcall(function()
RequestCommand:InvokeServer(";time 0 ;fogcolor black ;music 1846575559")
wait(1.5)
end)
RequestCommand:InvokeServer(";res all ;r6 all")
RequestCommand:InvokeServer(";volume 5")

print("âœ… Realm construction complete!")
end)


